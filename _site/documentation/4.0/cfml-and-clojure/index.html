<!DOCTYPE html>
<html lang="en-US">
<head>
	
	<meta charset="UTF-8">

	<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Using Clojure with CFML | FW/1 - The Invisible Framework</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Using Clojure with CFML" />
<meta name="author" content="Sean Corfield" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Framework One - is a family of small, lightweight, convention-over-configuration frameworks, primarily for CFML. FW/1 itself provides MVC, DI/1 provides dependency injection (a.k.a. inversion of control), and AOP/1 provides aspect-oriented programming features on top of DI/1." />
<meta property="og:description" content="Framework One - is a family of small, lightweight, convention-over-configuration frameworks, primarily for CFML. FW/1 itself provides MVC, DI/1 provides dependency injection (a.k.a. inversion of control), and AOP/1 provides aspect-oriented programming features on top of DI/1." />
<link rel="canonical" href="http://localhost:4000/documentation/4.0/cfml-and-clojure/" />
<meta property="og:url" content="http://localhost:4000/documentation/4.0/cfml-and-clojure/" />
<meta property="og:site_name" content="FW/1 - The Invisible Framework" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-09-16T20:00:00-04:00" />
<script type="application/ld+json">
{"headline":"Using Clojure with CFML","dateModified":"2016-09-16T20:00:00-04:00","datePublished":"2016-09-16T20:00:00-04:00","url":"http://localhost:4000/documentation/4.0/cfml-and-clojure/","author":{"@type":"Person","name":"Sean Corfield"},"description":"Framework One - is a family of small, lightweight, convention-over-configuration frameworks, primarily for CFML. FW/1 itself provides MVC, DI/1 provides dependency injection (a.k.a. inversion of control), and AOP/1 provides aspect-oriented programming features on top of DI/1.","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/documentation/4.0/cfml-and-clojure/"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<meta name="theme-color" content="#157878" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
	<link rel="stylesheet" href="/assets/css/style.css?v=a3debbe0e02ab81ebdefec1b0e258acd9a63d866" />
	<link href="/atom.xml" rel="alternate" title="FW/1 - The Invisible Framework" type="application/atom+xml">
</head>
<body>
	<a id="skip-to-content" href="#content">Skip to the content.</a>

	<header class="page-header" role="banner">
		<h1 class="project-name">Using Clojure with CFML</h1>
		<h2 class="project-tagline">Framework One - is a family of small, lightweight, convention-over-configuration frameworks, primarily for CFML. FW/1 itself provides MVC, DI/1 provides dependency injection (a.k.a. inversion of control), and AOP/1 provides aspect-oriented programming features on top of DI/1.</h2>
		
		<a href="/" class="btn">Home</a>
		<a href="/blog" class="btn">Blog</a>
		<a href="/documentation" class="btn">Documentation</a>
		
			<a href="https://github.com/framework-one/fw1/" class="btn" target="_blank">View on GitHub</a>
		
		
			<a href="https://github.com/framework-one/fw1/archive/master.zip" class="btn">Download 4.2 (Current)</a>
			<a href="https://github.com/framework-one/fw1/archive/v4.3.0-beta.1.zip" class="btn">Download 4.3 (Beta)</a>
		
		
			<a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS" class="btn">RSS</a>
		
	</header>

	<main id="content" class="main-content" role="main">
		<aside class="documentation-nav">
	<section>
		<a href="/documentation/changelog">Changelog</a><br />
		<a href="/documentation/roadmap/">Roadmap</a><br />
	</section>
	<section>
		<h3>4.3 Documentation (beta)</h3>
		<a href="/documentation/4.3/">Getting Started Guide</a><br />
		<a href="/documentation/4.3/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/4.3/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/4.3/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/4.3/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/4.3/reference-manual/">Reference Manual</a><br />
		<a href="/documentation/4.3/changelog/">Change Log</a><br />
	</section>
	<section>
		<h3>4.2 Documentation (Current Master)</h3>
		<a href="/documentation/4.2/">Getting Started Guide</a><br />
		<a href="/documentation/4.2/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/4.2/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/4.2/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/4.2/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/4.2/reference-manual/">Reference Manual</a><br />
		<a href="/documentation/4.2/changelog/">Change Log</a><br />
	</section>
	<section>
		<h3>4.1 Documentation</h3>
		<a href="/documentation/4.1/">Getting Started Guide</a><br />
		<a href="/documentation/4.1/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/4.1/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/4.1/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/4.1/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/4.1/reference-manual/">Reference Manual</a><br />
		<a href="/documentation/4.1/changelog/">Change Log</a><br />
	</section>
	<section>
		<h3>4.0 Documentation</h3>
		<a href="/documentation/4.0/">Getting Started Guide</a><br />
		<a href="/documentation/4.0/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/4.0/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/4.0/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/4.0/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/4.0/reference-manual/">Reference Manual</a><br />
		<a href="/documentation/4.0/changelog/">Change Log</a><br />
	</section>
	<section>
		<h3>3.5 Documentation</h3>
		<a href="/documentation/3.5/">Getting Started Guide</a><br />
		<a href="/documentation/3.5/cfml-and-clojure/">CFML and Clojure</a><br />
		<a href="/documentation/3.5/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/3.5/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/3.5/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/3.5/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/3.5/reference-manual/">Reference Manual</a><br />
	</section>
	<section>
		<h3>3.1 Documentation</h3>
		<a href="/documentation/3.1/">Getting Started Guide</a><br />
		<a href="/documentation/3.1/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/3.1/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/3.1/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/3.1/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/3.1/reference-manual/">Reference Manual</a><br />
	</section>
	<section>
		<h3>3.0 Documentation</h3>
		<a href="/documentation/3.0/">Getting Started Guide</a><br />
		<a href="/documentation/3.0/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/3.0/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/3.0/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/3.0/reference-manual/">Reference Manual</a><br />
	</section>
</aside>

<article>
	<h1 class="no_toc" id="clojure-and-cfml-sitting-in-a-tree">Clojure and CFML Sitting in a tree</h1>

<p>Back in 2010, I started to learn Clojure. It’s a version of the Lisp programming language that runs on the JVM. It’s a mostly pure functional programming language.
It’s very simple – very little syntax – but very powerful and expressive. It has a thriving community and ecosystem. Being a
functional programming language it favors immutable data structures and higher order functions (map, filter, reduce, etc) which
makes programs easy to reason about and it also makes concurrent programming pretty easy. No more thread safety issues!</p>

<p>Although Clojure can be compiled to JVM bytecode and deployed as a JAR or WAR file, it can also be treated like
a dynamic scripting language and compiled on-the-fly to JVM bytecode, just like CFML, giving you that very fast edit-reload-test
cycle that you’re used to with CFML. In fact, if you use the REPL (Read-Eval-Print-Loop) you can pretty much reduce that to
just edit-test since Clojure code is compiled as you type it in and can be evaluated immediately.</p>

<p>Because I was still writing a lot of CFML back in 2010, I figured out an easy way to allow you, as a CFML developer, to load
and run Clojure code within your CFML application. That functionality has been available via the standalone
<a href="https://github.com/framework-one/cfmljure">cfmljure library</a> for several years, and it has become core
to how the Internet dating platform works at my company (<a href="http://worldsinglesnetworks.com">World Singles Networks</a>). We’ve had
<strong>cfmljure</strong> in production since Spring 2011 and, in 2014, we declared Clojure to be our primary language and nearly all new
development happens in Clojure, hosted within three ColdBox applications and two FW/1 applications. Clojure powers all of our
standalone processes as well.</p>

<p>As we’ve come to depend on FW/1 more and more, I’ve wanted to streamline the integration between FW/1 and <strong>cfmljure</strong> so that
we can write services in Clojure and have them autowired into our controllers, just like our CFML services are, as well as have
the option to write controllers in Clojure (if all the code they need to call is Clojure, not some mix of CFML and Clojure).</p>

<p>That’s why, in FW/1 3.5, I’ve made <strong>cfmljure</strong> part of the standard distribution and provided an extension to DI/1 to allow
Clojure code to be discovered and autowired into your CFML code, as well as a way to write FW/1 controllers in pure Clojure.</p>

<ul id="markdown-toc">
  <li><a href="#some-important-caveats-and-system-requirements" id="markdown-toc-some-important-caveats-and-system-requirements">Some Important Caveats (and System Requirements)</a></li>
  <li><a href="#getting-started-with-clojure-and-cfml" id="markdown-toc-getting-started-with-clojure-and-cfml">Getting Started with Clojure and CFML</a>    <ul>
      <li><a href="#leiningen" id="markdown-toc-leiningen">Leiningen</a></li>
      <li><a href="#boot" id="markdown-toc-boot">Boot</a></li>
      <li><a href="#testing-fw1-40-and-clojure" id="markdown-toc-testing-fw1-40-and-clojure">Testing FW/1 4.0 and Clojure</a></li>
    </ul>
  </li>
  <li><a href="#the-6helloclojure-example-explained" id="markdown-toc-the-6helloclojure-example-explained">The 6helloclojure Example Explained</a>    <ul>
      <li><a href="#applicationcfc" id="markdown-toc-applicationcfc">Application.cfc</a></li>
      <li><a href="#myapplicationcfc" id="markdown-toc-myapplicationcfc">MyApplication.cfc</a></li>
      <li><a href="#views" id="markdown-toc-views">views</a></li>
      <li><a href="#srchellocontrollers" id="markdown-toc-srchellocontrollers">src/hello/controllers</a></li>
      <li><a href="#srchelloservices" id="markdown-toc-srchelloservices">src/hello/services</a></li>
      <li><a href="#testhello" id="markdown-toc-testhello">test/hello</a></li>
    </ul>
  </li>
  <li><a href="#fw1-conventions-with-clojure" id="markdown-toc-fw1-conventions-with-clojure">FW/1 Conventions with Clojure</a>    <ul>
      <li><a href="#uniqueness-of-namespace-to-bean-mappings" id="markdown-toc-uniqueness-of-namespace-to-bean-mappings">Uniqueness of Namespace to Bean Mappings</a></li>
      <li><a href="#additional-clojure-code" id="markdown-toc-additional-clojure-code">Additional Clojure Code</a></li>
      <li><a href="#configuring-frameworkioclj" id="markdown-toc-configuring-frameworkioclj">Configuring <code class="language-plaintext highlighter-rouge">framework.ioclj</code></a></li>
    </ul>
  </li>
  <li><a href="#what-is-ns-all-about" id="markdown-toc-what-is-ns-all-about">What is ns all about?</a></li>
  <li><a href="#building-your-own-cfml--clojure-application" id="markdown-toc-building-your-own-cfml--clojure-application">Building Your Own CFML / Clojure Application</a>    <ul>
      <li><a href="#creating-the-clojure-project" id="markdown-toc-creating-the-clojure-project">Creating the Clojure project</a></li>
      <li><a href="#accessing-a-database-from-clojure" id="markdown-toc-accessing-a-database-from-clojure">Accessing a Database from Clojure</a></li>
      <li><a href="#adding-the-initial-cfml-files" id="markdown-toc-adding-the-initial-cfml-files">Adding the initial CFML files</a></li>
      <li><a href="#writing-a-clojure-service" id="markdown-toc-writing-a-clojure-service">Writing a Clojure Service</a></li>
      <li><a href="#fleshing-out-the-views" id="markdown-toc-fleshing-out-the-views">Fleshing out the Views</a></li>
      <li><a href="#testing-with-a-cfml-controller" id="markdown-toc-testing-with-a-cfml-controller">Testing with a CFML Controller</a>        <ul>
          <li><a href="#using-the-clojure-service" id="markdown-toc-using-the-clojure-service">Using the Clojure Service</a></li>
        </ul>
      </li>
      <li><a href="#writing-a-clojure-controller" id="markdown-toc-writing-a-clojure-controller">Writing a Clojure Controller</a>        <ul>
          <li><a href="#rc-value-conversion" id="markdown-toc-rc-value-conversion">RC Value Conversion</a></li>
          <li><a href="#augmenting-rc-with-clojure-expressions" id="markdown-toc-augmenting-rc-with-clojure-expressions">Augmenting RC With Clojure Expressions</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#a-clojure-primer" id="markdown-toc-a-clojure-primer">A Clojure Primer</a>    <ul>
      <li><a href="#some-basic-clojure-functions" id="markdown-toc-some-basic-clojure-functions">Some Basic Clojure Functions</a>        <ul>
          <li><a href="#def-fn-and-defn" id="markdown-toc-def-fn-and-defn"><code class="language-plaintext highlighter-rouge">def</code>, <code class="language-plaintext highlighter-rouge">fn</code>, and <code class="language-plaintext highlighter-rouge">defn</code></a></li>
          <li><a href="#if-when-and-do" id="markdown-toc-if-when-and-do"><code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">when</code>, and <code class="language-plaintext highlighter-rouge">do</code></a></li>
          <li><a href="#let-and-its-cousins" id="markdown-toc-let-and-its-cousins"><code class="language-plaintext highlighter-rouge">let</code> and its cousins</a></li>
          <li><a href="#loop-and-recur" id="markdown-toc-loop-and-recur"><code class="language-plaintext highlighter-rouge">loop</code> and <code class="language-plaintext highlighter-rouge">recur</code></a></li>
          <li><a href="#useful-core-functions" id="markdown-toc-useful-core-functions">Useful core Functions</a></li>
        </ul>
      </li>
      <li><a href="#the-projectclj-file" id="markdown-toc-the-projectclj-file">The project.clj File</a></li>
      <li><a href="#the-buildboot-file" id="markdown-toc-the-buildboot-file">The build.boot File</a></li>
    </ul>
  </li>
  <li><a href="#about-functional-programming" id="markdown-toc-about-functional-programming">About Functional Programming</a>    <ul>
      <li><a href="#immutable-or-persistent-data-structures" id="markdown-toc-immutable-or-persistent-data-structures">Immutable or Persistent Data Structures</a></li>
      <li><a href="#functions-as-building-blocks" id="markdown-toc-functions-as-building-blocks">Functions as Building Blocks</a></li>
      <li><a href="#all-you-know-about-oo-programming-is-wrong" id="markdown-toc-all-you-know-about-oo-programming-is-wrong">All You Know About OO Programming is Wrong</a></li>
    </ul>
  </li>
  <li><a href="#more-stuff-to-read" id="markdown-toc-more-stuff-to-read">More Stuff to Read</a></li>
  <li><a href="#digging-into-reloading" id="markdown-toc-digging-into-reloading">Digging Into Reloading</a></li>
</ul>

<h2 id="some-important-caveats-and-system-requirements">Some Important Caveats (and System Requirements)</h2>

<p>Before you get started, there are a handful of things you need to be aware of:</p>

<ul>
  <li>The Clojure integration works best on <strong>Lucee</strong> (4.5 or later) or <strong>Railo</strong> (4.2). ColdFusion 11 is supported too but interop between CFML and Clojure
can get pretty ugly (see the <a href="https://github.com/framework-one/cfmljure/blob/master/index-acf.cfm">ColdFusion-specific examples</a>
in the <strong>cfmljure</strong> project repo for more details). I doubt it will run on ColdFusion 10 or earlier. I developed exclusively
on Railo from 2009 to 2015 and now I develop on Lucee. Thank <a href="https://github.com/am2605">Andrew Myers</a> for the ColdFusion 11
support!</li>
  <li>You should be running <strong>Java 8</strong> at this point. The Clojure integration <em>will not work on Java 6</em>. It has not been tested on Java 7.
The Java 6 EOL notice was February 2011 and public updates stopped in February 2011. The Java 7 EOL notice was March 2014 and public
updates stopped in April 2015.</li>
  <li>Clojure developers are pretty comfortable at the command line, so the build tool you’ll need to install for this is a command
line tool: be prepared to work in Terminal / Console quite a bit!</li>
  <li>Clojure developers use editors that auto-close parentheses, brackets, and braces. Most of those editors also support “structural
editing” which means they understand expressions enclosed in matched pairs of parentheses (or brackets or braces) and let you
easily manipulate <em>expressions</em> rather than just text. There are plugins for Eclipse, Sublime Text, IntelliJ and several others.
Most Clojure developers use Emacs or Vim. I use Emacs for all my editing, CFML included.</li>
  <li>In order to use Clojure with CFML, you <strong>must not run your CFML server under the root account</strong> (on Mac or Linux). It’s something
you should never do in production anyway for security reasons, and there’s really no reason to do it on your development machine
either. <strong>cfmljure</strong> checks this for you and refuses to initialize (and throws a helpful exception).</li>
  <li>For ease of debugging any problems that may occur, I <em>strongly</em> recommend you always keep a Terminal / Console window open
containing a tail of the console output from your CFML server. If you’re using Lucee or a Railo installation based on Tomcat,
you’ll want to find the <code class="language-plaintext highlighter-rouge">catalina.out</code> log file and tail that. If you’re using ColdFusion 11, even tho’ it is notionally based
on Tomcat, it’s completely non-standard and you’ll want to tail <code class="language-plaintext highlighter-rouge">cfusion/logs/coldfusion-out.log</code>.</li>
  <li>Finally, <strong>cfmljure</strong> uses a lock file to ensure that a couple of things it does during initialization are single-threaded
across the whole server, no matter how your CFML server and application instances are configured. On Mac and Linux, it
creates (and deletes) <code class="language-plaintext highlighter-rouge">/tmp/cfmljure.lock</code>. On Windows, it creates (and deletes) <code class="language-plaintext highlighter-rouge">cfmljure.lock</code> in your <code class="language-plaintext highlighter-rouge">TEMP</code> folder which
is normally in the <code class="language-plaintext highlighter-rouge">AppData</code> folder off your local accounts home folder – check your <code class="language-plaintext highlighter-rouge">TEMP</code> environment variable for the
exact location. <strong>cfmljure</strong> tries really hard to clean up after itself but if something goes badly wrong during initialization,
it’s possible the lock file will be left behind and you will need to manually delete it. <strong>cfmljure</strong> will try its best to
let you know if it needs you to delete the lock file – but if you’re tailing the logs, you’ll see messages as the
initialization proceeds.</li>
</ul>

<h2 id="getting-started-with-clojure-and-cfml">Getting Started with Clojure and CFML</h2>

<p>Clojure has two standard build tools, called <a href="http://leiningen.org">Leiningen</a> and <a href="http://boot-clj.com/">Boot</a>. The former has been around
longer and is currently the most popular. The latter is more general purpose. FW/1, via cfmljure, supports both build tools. These tools manage all of your project dependencies
(e.g., automatically downloading and installing any libraries you need) as well as providing a REPL for
interactive development, running your tests, packaging applications into JAR files, deploying them to standard repositories and so on.</p>

<p><strong>cfmljure</strong> leverages <strong>Leiningen</strong> or <strong>Boot</strong> to figure out the complete classpath that your Clojure code needs – including any
libraries you use – so that it can easily load all the JAR files (and Clojure source code) into your CFML server.</p>

<p>The first step to using FW/1 and Clojure together is to install one (or both!) of these build tools and make sure it is working.
We’re going to look at both build tools – support for <strong>Boot</strong> is new in release 4.0.</p>

<h3 id="leiningen">Leiningen</h3>

<p>In addition to managing your project dependencies, <strong>Leiningen</strong> also provides a template system for new projects, so it’s the most
convenient way to get up and running right now. Since we want to create a test project without needing to manually set up various
files, I recommend starting with <strong>Leiningen</strong> – and looking at <strong>Boot</strong> later on. <em>For what it’s worth, World Singles has just
switched from <strong>Leiningen</strong> to <strong>Boot</strong>, in order to leverage the increased flexibility that tool offers.</em></p>

<p>If you’re on Mac or Linux, follow the <a href="http://leiningen.org/#install">Leiningen Install steps</a> for the <code class="language-plaintext highlighter-rouge">lein</code> shell script.</p>

<p>If you’re on Windows, I recommend using the <a href="http://leiningen-win-installer.djpowell.net/">Installer for Windows users</a> mentioned
near the end of that <strong>Install</strong> section.</p>

<p>Once you have it installed, open up a new Terminal / Console window and navigate to directory where you can create a project to
test that it is working properly, then do this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lein new app myapp
</code></pre></div></div>

<p>It will probably download a bunch of libraries the first time you run it, but it should (eventually) respond:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Generating a project called myapp based on the 'app' template.
</code></pre></div></div>

<p>Now go into that project and run it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd myapp
lein run
</code></pre></div></div>

<p>It should say:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello, World!
</code></pre></div></div>

<p>Congratulations! <strong>Leiningen</strong> is installed and working!</p>

<p>BTW, <strong>Leiningen</strong> supports unit testing out of the box, so in addition to creating an application skeleton for <code class="language-plaintext highlighter-rouge">myapp</code>,
it also generates a test skeleton which you can run like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lein test
</code></pre></div></div>

<p>Because the test skeleton doesn’t have any valid tests – just one deliberate failure – you should see:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lein test myapp.core-test

lein test :only myapp.core-test/a-test

FAIL in (a-test) (core_test.clj:7)
FIXME, I fail.
expected: (= 0 1)
  actual: (not (= 0 1))

Ran 1 tests containing 1 assertions.
1 failures, 0 errors.
Tests failed.
</code></pre></div></div>

<p>When you start developing services and controllers in Clojure, you’ll find it handy to write unit tests as you go and run
them with <code class="language-plaintext highlighter-rouge">lein test</code>!</p>

<h3 id="boot">Boot</h3>

<p>Follow the <a href="https://github.com/boot-clj/boot#install">Boot Install steps</a> for either “Unix, Linux, OSX” or “Windows”. You’ll notice the Windows installation is much simpler than for <strong>Leiningen</strong>.</p>

<p>You should go through the <a href="https://github.com/boot-clj/boot#getting-started">Getting Started</a> section to verify that <strong>Boot</strong> is installed and working (<code class="language-plaintext highlighter-rouge">boot -h</code>, <code class="language-plaintext highlighter-rouge">boot repl</code>).</p>

<p><strong>Boot</strong> has an external task to create new projects but it works almost exactly like the <code class="language-plaintext highlighter-rouge">new</code> task that <strong>Leiningen</strong> has built-in:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>boot -d seancorfield/boot-new new -t app -n myapp
</code></pre></div></div>

<p>This specifies an external dependency (on my <code class="language-plaintext highlighter-rouge">boot-new</code> task library), then the name of the task (<code class="language-plaintext highlighter-rouge">new</code>) then the arguments to that task (the <code class="language-plaintext highlighter-rouge">t</code>ype
of the template and <code class="language-plaintext highlighter-rouge">n</code>ame of project to create).</p>

<p>If you want to get going quickly and you’ve already installed <strong>Leiningen</strong> and gone through the project creation and testing steps above, you can just create a <code class="language-plaintext highlighter-rouge">build.boot</code> file in
that (<strong>Leiningen</strong>-created) project and run code and tests like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>;; build.boot
(set-env! :resource-paths #{"src"}
          :dependencies '[[org.clojure/clojure "1.8.0"]])

(require 'myapp.core)
(deftask run []
  (myapp.core/-main))
</code></pre></div></div>

<p>Like <code class="language-plaintext highlighter-rouge">project.clj</code> under <strong>Leiningen</strong>, we specify the project dependencies. We also specify where our source code is – there’s no default – using <code class="language-plaintext highlighter-rouge">:resource-paths</code>.
Next we load the main namespace of our new application and define a task called <code class="language-plaintext highlighter-rouge">run</code> that calls the main function in that application. Whilst <strong>Leiningen</strong> has a
built-in task called <code class="language-plaintext highlighter-rouge">run</code>, you still have to declare the main namespace (or specify it as a command line argument). <strong>Boot</strong> takes the approach that this is
“just code” so you can define whatever tasks you want, to run whatever Clojure code you want.</p>

<p>Accordingly, <strong>Boot</strong> does not have a built-in task to run tests, but there are readily available libraries to provide this functionality. We’ll update <code class="language-plaintext highlighter-rouge">build.boot</code> as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>;; build.boot
(set-env! :resource-paths #{"src"}
          :source-paths #{"test"}
          :dependencies '[[org.clojure/clojure "1.8.0"]
                          [adzerk/boot-test "1.0.7"]])

(require '[adzerk.boot-test :refer [test]])

(require 'myapp.core)
(deftask run []
  (myapp.core/-main))
</code></pre></div></div>

<p>We tell <strong>Boot</strong> where our test code is, we add a dependency on <code class="language-plaintext highlighter-rouge">boot-test</code> and we load that library and import the <code class="language-plaintext highlighter-rouge">test</code> task. Now we can run our tests:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>boot test
</code></pre></div></div>

<p>The output will be somewhat different to that produced by <code class="language-plaintext highlighter-rouge">lein test</code> above but you will see the same failing test, followed by an exception that indicates the build failed (this is common to <strong>Boot</strong> tasks as a way to report build failures).</p>

<p>A note on <code class="language-plaintext highlighter-rouge">:resource-paths</code> and <code class="language-plaintext highlighter-rouge">:source-paths</code>: <strong>Boot</strong> considers files that are part of the classpath and also intended to be an output of the project (such as contents of a JAR file) to be “resources”; files that are part of the classpath but not intended to be an output of the project are “sources”. That seems a bit confusing at first (source files are resources, test files are sources), but as you work more with <strong>Boot</strong> you get used to more things being resources, not just source files, so it soon makes a lot of sense.</p>

<p>Now we’ll move on to using FW/1 and Clojure together, and show how both <strong>Leiningen</strong> and <strong>Boot</strong> can be used.</p>

<h3 id="testing-fw1-40-and-clojure">Testing FW/1 4.0 and Clojure</h3>

<p>At this point you should be able to start your CFML server (remember: not under the <strong>root</strong> account!) and, with FW/1 4.0
installed (and possibly with a <code class="language-plaintext highlighter-rouge">/framework</code> mapping set up, or with the <code class="language-plaintext highlighter-rouge">framework</code> folder moved into your webroot), you
should be able to run all of the FW/1 examples. Make sure examples 1-5 work, then try <code class="language-plaintext highlighter-rouge">6helloclojure</code>.</p>

<p>If it doesn’t seem to run correctly, and there’s no obvious exception information in the browser or useful information in the
log file, you can try to re-run the <code class="language-plaintext highlighter-rouge">6helloclojure</code> example with <code class="language-plaintext highlighter-rouge">?cfmljure=abortOnFailure</code> added to the URL. This should
dump a whole bunch of information to the browser as well as any exception encountered.</p>

<p>If that doesn’t help, add <code class="language-plaintext highlighter-rouge">diConfig : { debug : true }</code> to the <code class="language-plaintext highlighter-rouge">variables.framework</code> configuration in <code class="language-plaintext highlighter-rouge">Application.cfc</code> for
that example and try again. This will output more information to the CFML server’s console log (which you’re tailing, right?).</p>

<p>If you can’t figure out the problem from all this extra debugging information, at least you’ll have it all available
when you post to the FW/1 mailing list, asking for help!</p>

<p>At this point, however, I hope you got the example to run and you were able to try out the various links and see what it was
doing in the trace output in the browser, and perhaps by looking at the code, which we’ll go over next.</p>

<p>By default, <code class="language-plaintext highlighter-rouge">6helloclojure</code> relies on <strong>Leiningen</strong>. To use <strong>Boot</strong> instead, add <code class="language-plaintext highlighter-rouge">diConfig : { boot : "boot" }</code> to the
<code class="language-plaintext highlighter-rouge">variables.framework</code> configuration (or merge it with your <code class="language-plaintext highlighter-rouge">debug</code> setting). If <strong>Boot</strong> isn’t on the PATH used by your CFML server,
you can specify the full file path to the <strong>Boot</strong> shell script or executable using that <code class="language-plaintext highlighter-rouge">boot</code> configuration (instead of just <code class="language-plaintext highlighter-rouge">"boot"</code>).</p>

<h2 id="the-6helloclojure-example-explained">The 6helloclojure Example Explained</h2>

<p>If you look in the <code class="language-plaintext highlighter-rouge">6helloclojure</code> folder (in <code class="language-plaintext highlighter-rouge">examples/subsystems/</code>), you’ll see a combination of things you expect to see in a FW/1 application and
files and folders that would see in your <code class="language-plaintext highlighter-rouge">myapp</code> Clojure test project above:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Application.cfc MyApplication.cfc index.cfm views
.gitignore LICENSE README.md doc resources target
boot.properties build.boot project.clj src test
</code></pre></div></div>

<p>The files shown in the first line are for FW/1. You might later add a <code class="language-plaintext highlighter-rouge">controllers</code> folder and a <code class="language-plaintext highlighter-rouge">model</code> folder if you
write any of those pieces in CFML.</p>

<p>The files shown in the second line are generated by <strong>Leiningen</strong> and you can pretty much ignore them. You’ll see that by
default a Leiningen-generated Clojure project is assumed to live under version control with <code class="language-plaintext highlighter-rouge">git</code>, have an open source
software license (Eclipse Public License 1.0 by default), have a README (markdown) file that explains what the project is for and
how to use it, a documentation folder, possibly some non-source code resource files (configuration files or perhaps
assets for a web application), and you may see a <code class="language-plaintext highlighter-rouge">target</code> folder which is used by <strong>Leiningen</strong> for compiling code and
generating JAR files etc.</p>

<p>The files shown in the third line are the important parts of the Clojure code:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">boot.properties</code> (for <strong>Boot</strong>) defines the configuration of <strong>Boot</strong> itself: the specific version of <strong>Boot</strong>, <strong>Clojure</strong>, and so on.</li>
  <li><code class="language-plaintext highlighter-rouge">build.boot</code> (for <strong>Boot</strong>) defines the dependencies of
your project (the libraries it needs), as well as any development or test tooling (as tasks) etc. The license, description, and URL information listed in <code class="language-plaintext highlighter-rouge">project.clj</code> can be specified for <strong>Boot</strong> but that is out of the scope of this documentation.</li>
  <li><code class="language-plaintext highlighter-rouge">project.clj</code> (for <strong>Leiningen</strong>) defines the dependencies of
your project (the libraries it needs), as well as any development or test tooling (as plugins) and several other
important aspects of how to run, test, and package your code. You’ll notice that it also has a description, a URL for
where to find the project (e.g., on GitHub), and details of the license.</li>
  <li><code class="language-plaintext highlighter-rouge">src</code> is where your Clojure source code lives. Clojure itself places very few restrictions on the structure of this
(beyond assuming that the file structure matches the namespace structure within the Clojure source files, much the
same way Java’s file structure matches its package structure). If you have a Clojure namespace with <code class="language-plaintext highlighter-rouge">-</code> in its name,
the corresponding folder will have <code class="language-plaintext highlighter-rouge">_</code> in its name.</li>
  <li><code class="language-plaintext highlighter-rouge">test</code> is where your Clojure test code lives. It’s a common convention that if your source file is <code class="language-plaintext highlighter-rouge">foo/bar/baz.clj</code>
which will have a namespace of <code class="language-plaintext highlighter-rouge">foo.bar.baz</code>, then the tests for that code will live in <code class="language-plaintext highlighter-rouge">foo/bar/baz_test.clj</code> with
a namespace of <code class="language-plaintext highlighter-rouge">foo.bar.baz-test</code>. We have <code class="language-plaintext highlighter-rouge">hello/controllers/main_test.clj</code> which contains tests for the source code
in <code class="language-plaintext highlighter-rouge">hello/controllers/main.clj</code>.</li>
</ul>

<p>If you run <code class="language-plaintext highlighter-rouge">lein test</code> in the <code class="language-plaintext highlighter-rouge">6helloclojure</code> folder, you’ll see:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lein test hello.controllers.main-test

lein test hello.services.greeter-test

Ran 2 tests containing 3 assertions.
0 failures, 0 errors.
</code></pre></div></div>

<p>We’ll take a look at that in a minute. You can also run <code class="language-plaintext highlighter-rouge">boot test</code> (if you have <strong>Boot</strong> installed) and you will see similar output.</p>

<p>Let’s start with the CFML files and look at <code class="language-plaintext highlighter-rouge">Application.cfc</code> first, then the <code class="language-plaintext highlighter-rouge">views</code> folder. As usual <code class="language-plaintext highlighter-rouge">index.cfm</code> is an empty file.</p>

<h3 id="applicationcfc">Application.cfc</h3>

<p>This is based on <code class="language-plaintext highlighter-rouge">/framework/Application.cfc</code> and allows us to use FW/1 without a global mapping. It creates a per-application mapping for
<code class="language-plaintext highlighter-rouge">/framework</code> via a relative path using <code class="language-plaintext highlighter-rouge">expandPath( '../../../framework' )</code>, and then it creates an instance of <code class="language-plaintext highlighter-rouge">MyApplication.cfc</code>, passing in the
FW/1 configuration structure.</p>

<p>There are a few items of note here, and the first is that we specify <code class="language-plaintext highlighter-rouge">diComponent</code> as <code class="language-plaintext highlighter-rouge">"framework.ioclj"</code> to tell FW/1 that we want to use <code class="language-plaintext highlighter-rouge">ioclj.cfc</code>
rather than the default <code class="language-plaintext highlighter-rouge">ioc.cfc</code> for the Dependency Injection component (the bean factory). <code class="language-plaintext highlighter-rouge">ioclj.cfc</code> extends DI/1 and
provides the Clojure-specific magic. Note that we leave <code class="language-plaintext highlighter-rouge">diEngine</code> as the default (which is <code class="language-plaintext highlighter-rouge">"di1"</code>) because <code class="language-plaintext highlighter-rouge">ioclj.cfc</code> is just an extension to DI/1.</p>

<p>Next we specify <code class="language-plaintext highlighter-rouge">diLocations</code> as the full filesystem path of the current folder. In a CFML / Clojure application, you potentially need to tell the bean factory
about three things:</p>

<ul>
  <li>Where to look for your CFML beans (if any).</li>
  <li>Where to find your <code class="language-plaintext highlighter-rouge">project.clj</code> or <code class="language-plaintext highlighter-rouge">build.boot</code> file.</li>
  <li>Where to find Clojure <code class="language-plaintext highlighter-rouge">src</code> folders to look for Clojure source code to be “managed” (and autowired).</li>
</ul>

<p>Locations are specified as
either a comma-separated list of file paths, or an array of paths, and one of them must specify the exact directory path to where <code class="language-plaintext highlighter-rouge">project.clj</code> or <code class="language-plaintext highlighter-rouge">build.boot</code> lives.
By default, each path is searched in order, for each of the three types of files.
That means you can store both your Clojure code and your CFML beans in the same tree structure if you wish, or
you can store them separately and provide multiple file paths in <code class="language-plaintext highlighter-rouge">diLocations</code>. File paths may optionally be prefixed with <code class="language-plaintext highlighter-rouge">clj:</code> or <code class="language-plaintext highlighter-rouge">cfml:</code> which
will restrict searching to just that type of file.</p>

<p>If you want to run <code class="language-plaintext highlighter-rouge">6helloclojure</code> with <strong>Boot</strong>, just add <code class="language-plaintext highlighter-rouge">diConfig : { boot : "boot" }</code> into the framework configuration and reload the application.</p>

<h3 id="myapplicationcfc">MyApplication.cfc</h3>

<p>This is based on <code class="language-plaintext highlighter-rouge">/framework/MyApplication.cfc</code> and allows us to override parts of FW/1. It extends <code class="language-plaintext highlighter-rouge">framework.one</code> (using the per-application
mapping created in <code class="language-plaintext highlighter-rouge">Application.cfc</code>), and then overrides any FW/1 we want to customize.</p>

<p>The code of note is that <code class="language-plaintext highlighter-rouge">setupRequest()</code> reloads the Clojure code whenever the framework itself is reloaded.
Normally, in
a FW/1 app, you can specify an application reload and your bean factory is recreated. Because of the way Clojure code is compiled and loaded
into the JVM, reloading your bean factory is not sufficient to force a reload of those parts of the JVM, so you need to do this programmatically
somehow. Note that this will only reload the namespaces that follow the FW/1 conventions to be discovered. See below for more on this.</p>

<h3 id="views">views</h3>

<p>This is a regular FW/1 views folder, containing a subfolder for each section of the app (just <code class="language-plaintext highlighter-rouge">main</code> in this case) and a file for each item (there are
three views here). As expected we have a <code class="language-plaintext highlighter-rouge">main.default</code> view and a <code class="language-plaintext highlighter-rouge">main.error</code> view which are basic defaults for FW/1 applications. We also have
a <code class="language-plaintext highlighter-rouge">main.stopped</code> view. We’ll see how each of these is used when we look at the <code class="language-plaintext highlighter-rouge">main</code> controller.</p>

<p>The <code class="language-plaintext highlighter-rouge">default</code> view references <code class="language-plaintext highlighter-rouge">rc.greeting</code> which we’ll see being set up in the <code class="language-plaintext highlighter-rouge">main.clj</code> controller below, and it also gets a <code class="language-plaintext highlighter-rouge">greeterService</code> from
the bean factory and calls a function in that. We’ll see where <code class="language-plaintext highlighter-rouge">greeterService</code> comes from below as well.</p>

<h3 id="srchellocontrollers">src/hello/controllers</h3>

<p>In this folder we have a single Clojure file, <code class="language-plaintext highlighter-rouge">main.clj</code>. As you might guess from the file path, this is our application controller. Inside you’ll
see a namespace declaration (the <code class="language-plaintext highlighter-rouge">ns</code> expression) and four functions which represent our handlers.</p>

<p>As with CFML controller functions, each function is passed an argument called <code class="language-plaintext highlighter-rouge">rc</code> which is the request context. Unlike CFML controllers
which might modify elements of the <code class="language-plaintext highlighter-rouge">rc</code> struct directly,
Clojure controllers return an updated version of the <code class="language-plaintext highlighter-rouge">rc</code> data structure to the framework.</p>

<p>In the <code class="language-plaintext highlighter-rouge">default</code> handler, we get the <code class="language-plaintext highlighter-rouge">:name</code> element of the <code class="language-plaintext highlighter-rouge">rc</code> and we return <code class="language-plaintext highlighter-rouge">rc</code> with an additional element called <code class="language-plaintext highlighter-rouge">:greeting</code>. In Clojure,
<code class="language-plaintext highlighter-rouge">(:foo bar)</code> is roughly equivalent to CFML’s <code class="language-plaintext highlighter-rouge">bar.foo</code>, and <code class="language-plaintext highlighter-rouge">(:foo bar "baz")</code> is similar to:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>structKeyExists( bar, "foo" ) ? bar.foo : "baz"
</code></pre></div></div>

<p>So <code class="language-plaintext highlighter-rouge">default</code> passes <code class="language-plaintext highlighter-rouge">rc.name</code> (or <code class="language-plaintext highlighter-rouge">"anonymous"</code> if <code class="language-plaintext highlighter-rouge">name</code> isn’t present in <code class="language-plaintext highlighter-rouge">rc</code>) to the <code class="language-plaintext highlighter-rouge">greet/hello</code> function and then stores the result in
the <code class="language-plaintext highlighter-rouge">greeting</code> element of <code class="language-plaintext highlighter-rouge">rc</code>. Note that the <code class="language-plaintext highlighter-rouge">assoc</code> function (pronounced <em>assosh</em> like the word <em>associate</em>) returns a new struct with the
key added – it does not modify the original struct. This seems very strange at first but you’ll get used to it and it’s very powerful (and
very safe) since <code class="language-plaintext highlighter-rouge">rc</code> is immutable. We’ll look at where <code class="language-plaintext highlighter-rouge">greet/hello</code> comes from in a minute.</p>

<p>Next we have the <code class="language-plaintext highlighter-rouge">do-redirect</code> handler. Yes, Clojure functions can have <code class="language-plaintext highlighter-rouge">-</code> in their names. The standard naming convention in Clojure is <em>words-like-this</em>
rather than <em>wordsLikeThis</em> or <em>WordsLikeThis</em>. It’s a long-standing Lisp tradition. Yes, it’s strange but you’ll get used to it and you’ll
soon find it more readable than CamelCase. Anyway, this handler tells FW/1 to redirect to <code class="language-plaintext highlighter-rouge">main.default</code> with the specified query string.
Adding a key called <code class="language-plaintext highlighter-rouge">:redirect</code> to <code class="language-plaintext highlighter-rouge">rc</code> is the equivalent of calling <code class="language-plaintext highlighter-rouge">variables.fw.redirect()</code> in a pure CFML FW/1 app. All four arguments
to the <code class="language-plaintext highlighter-rouge">redirect()</code> function can be specified as keys in the <code class="language-plaintext highlighter-rouge">:redirect</code> struct (<code class="language-plaintext highlighter-rouge">:append</code>, <code class="language-plaintext highlighter-rouge">:preserve</code>, <code class="language-plaintext highlighter-rouge">:queryString</code>, <code class="language-plaintext highlighter-rouge">:statusCode</code>).</p>

<p>Then we have the <code class="language-plaintext highlighter-rouge">stop-it</code> handler. By the way, the URL actions that correspond to <code class="language-plaintext highlighter-rouge">do-redirect</code> and <code class="language-plaintext highlighter-rouge">stop-it</code> are <code class="language-plaintext highlighter-rouge">do_redirect</code> and
<code class="language-plaintext highlighter-rouge">stop_it</code> respectively, following the filesystem convention of swapping <code class="language-plaintext highlighter-rouge">_</code> for <code class="language-plaintext highlighter-rouge">-</code> in Clojure. This handler tells FW/1 it wants to
abort the controller cycle and also set the view to the <code class="language-plaintext highlighter-rouge">main.stopped</code> action. Adding a key called <code class="language-plaintext highlighter-rouge">:abort</code> with a value of <code class="language-plaintext highlighter-rouge">:controller</code>
is equivalent to calling <code class="language-plaintext highlighter-rouge">variables.fw.abortController()</code>. Adding a key called <code class="language-plaintext highlighter-rouge">:view</code> is equivalent to calling
<code class="language-plaintext highlighter-rouge">variables.fw.setView()</code>. You’ll note that <code class="language-plaintext highlighter-rouge">assoc</code> can take any number of key/value pairs and add them all into the given struct.</p>

<p>Finally we have the <code class="language-plaintext highlighter-rouge">json</code> handler. By this point, it won’t surprise you to learn that this tells FW/1 to render the specified data
as JSON. The Clojure struct <code class="language-plaintext highlighter-rouge">{:a 1 :b "two" :c [3 4 5]}</code> is equivalent to the CFML struct <code class="language-plaintext highlighter-rouge">{a : 1, b : "two", c : [3, 4, 5]}</code>.
The <strong><a href="#a-clojure-primer">Clojure Primer</a></strong> below explains basic symbols and data structures, when you’re ready to read more about this.</p>

<h3 id="srchelloservices">src/hello/services</h3>

<p>In this folder we have a single Clojure file, <code class="language-plaintext highlighter-rouge">greeter.clj</code>. As with the controller convention, the file path tells FW/1 that this is
a service (and it would be autowired into any CFML code that declared <code class="language-plaintext highlighter-rouge">property greeterService;</code> as a dependency). This can also be
pulled from the bean factory as <code class="language-plaintext highlighter-rouge">"greeterService"</code>, as seen in the <code class="language-plaintext highlighter-rouge">main.default</code> view file.</p>

<p>There’s a single function <code class="language-plaintext highlighter-rouge">hello</code> in here that takes a string and returns it wrapped with <code class="language-plaintext highlighter-rouge">"Hello "</code> and <code class="language-plaintext highlighter-rouge">"!"</code>.</p>

<h3 id="testhello">test/hello</h3>

<p>Finally, we’ll look at the tests, first for the <code class="language-plaintext highlighter-rouge">main</code> controller, then the <code class="language-plaintext highlighter-rouge">greeter</code> service.</p>

<p>In <code class="language-plaintext highlighter-rouge">controllers/main_test.clj</code>, we have one test function <code class="language-plaintext highlighter-rouge">default-item-test</code> which contains two related
tests. The arrow syntax means “take this thing and pass it through these functions” so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(-&gt; {} default :greeting)
</code></pre></div></div>

<p>takes an empty struct and passes it as the first argument to the <code class="language-plaintext highlighter-rouge">default</code> function (our handler method being tested) and then
pass the result to the <code class="language-plaintext highlighter-rouge">:greeting</code> function – remember that <code class="language-plaintext highlighter-rouge">(:greeting my-struct)</code> is like <code class="language-plaintext highlighter-rouge">my_struct.greeting</code> in CFML. So
this tests that if the <code class="language-plaintext highlighter-rouge">rc</code> is empty and you run <code class="language-plaintext highlighter-rouge">main.default</code> you get a new key called <code class="language-plaintext highlighter-rouge">:greeting</code> whose value is <code class="language-plaintext highlighter-rouge">"Hello anonymous!"</code>.</p>

<p>The second test checks that if <code class="language-plaintext highlighter-rouge">rc</code> contains a <code class="language-plaintext highlighter-rouge">:name</code> element, you get back the appropriate greeting based on the value of that.</p>

<p>The <code class="language-plaintext highlighter-rouge">(testing "label" ...)</code> expression can have multiple <code class="language-plaintext highlighter-rouge">is</code> tests in it, even tho’ ours do not.</p>

<p>In <code class="language-plaintext highlighter-rouge">services/greeter_test.clj</code>, we again have one test function <code class="language-plaintext highlighter-rouge">hello-test</code> that verifies the <code class="language-plaintext highlighter-rouge">hello</code> function does what we expect.</p>

<h2 id="fw1-conventions-with-clojure">FW/1 Conventions with Clojure</h2>

<p>The naming and file path conventions for how you structure your Clojure code for use with FW/1 should be familiar to you if you’ve
already used DI/1 in the past: plural folder names, containing “components”, become beans named for the component, with a suffix that
is the singular of the folder name:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">src/hello/controllers/main.clj</code> -&gt; <code class="language-plaintext highlighter-rouge">mainController</code></li>
  <li><code class="language-plaintext highlighter-rouge">src/hello/services/greeter.clj</code> -&gt; <code class="language-plaintext highlighter-rouge">greeterService</code></li>
</ul>

<p>In a typical Clojure application, you have <code class="language-plaintext highlighter-rouge">src/</code> and <code class="language-plaintext highlighter-rouge">test/</code> folders containing your source code and your test code. Then you have
the top-level name of your application – <code class="language-plaintext highlighter-rouge">hello</code> in the paths above – and then below that you have all your Clojure “components”.</p>

<p>Therefore, FW/1 requires that there are at least three “segments” in a file path and name for this convention:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">src/myapp/controllers/main.clj</code> has <code class="language-plaintext highlighter-rouge">myapp.controllers.main</code> as the namespace – three segments – becomes <code class="language-plaintext highlighter-rouge">mainController</code></li>
  <li><code class="language-plaintext highlighter-rouge">src/hello/admin/services/user.clj</code> has <code class="language-plaintext highlighter-rouge">hello.admin.services.user</code> as the namespace – four segments – becomes <code class="language-plaintext highlighter-rouge">userService</code></li>
</ul>

<p>That means that just <code class="language-plaintext highlighter-rouge">src/controllers/main.clj</code> would not match the convention as its namespace would be <code class="language-plaintext highlighter-rouge">controllers.main</code> (only two
segments – no top-level application name).</p>

<p>FW/1 looks for the first plural segment that follows the top-level application name, and if there are multiple segments after that first
plural segment, they are concatenated to form the bean name:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">src/myapp/common/libraries/security/checker.clj</code> has <code class="language-plaintext highlighter-rouge">myapp.common.libraries.security.checker</code> as the namespace and, assuming <code class="language-plaintext highlighter-rouge">liberal : true</code>
is specified in the configuration, <code class="language-plaintext highlighter-rouge">libraries</code> will be seen as the first plural and mapped to <code class="language-plaintext highlighter-rouge">library</code>, and then the bean name will be
<code class="language-plaintext highlighter-rouge">securityChecker</code>, so the full bean name will be <code class="language-plaintext highlighter-rouge">securityCheckerLibrary</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">src/myapp/jobs/mail/alerts.clj</code> has <code class="language-plaintext highlighter-rouge">myapp.jobs.mail.alerts</code> as the namespace and the first plural is <code class="language-plaintext highlighter-rouge">jobs</code>, so the full bean name
will be <code class="language-plaintext highlighter-rouge">mailAlertsJob</code>.</li>
</ul>

<p>Note: without <code class="language-plaintext highlighter-rouge">liberal : true</code> in the <code class="language-plaintext highlighter-rouge">diConfig</code> structure, <code class="language-plaintext highlighter-rouge">libraries</code> would still be treated as plural but the singular would
be assumed to be <code class="language-plaintext highlighter-rouge">librarie</code>!</p>

<h3 id="uniqueness-of-namespace-to-bean-mappings">Uniqueness of Namespace to Bean Mappings</h3>

<p>One additional restriction for FW/1 to automatically manage injection of Clojure namespaces
into your CFCs is that the filename + suffix must be unique across your whole application within the Clojure code (so also having
<code class="language-plaintext highlighter-rouge">src/hello/public/services/user.clj</code> would conflict with <code class="language-plaintext highlighter-rouge">src/hello/admin/services/user.clj</code>, but not <code class="language-plaintext highlighter-rouge">src/hello/services/admin/user.clj</code>
which would be mapped to <code class="language-plaintext highlighter-rouge">adminUserService</code>).</p>

<h3 id="additional-clojure-code">Additional Clojure Code</h3>

<p>Aside: You can have additional Clojure code that doesn’t follow this convention, but the bean factory <code class="language-plaintext highlighter-rouge">reload()</code> function only attempts to
reload Clojure files that it “knows” about via this convention. You can explicitly reload others – if you allow for a URL variable that can
be passed to the <code class="language-plaintext highlighter-rouge">reload()</code> method of the bean factory, identifying a single namespace –
but there are some subtleties there which are beyond the scope of this
documentation (if you want to learn more, read the <a href="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/require">clojure.core/require docstring</a>
and know that <code class="language-plaintext highlighter-rouge">reload("all")</code> does <code class="language-plaintext highlighter-rouge">(require ... :reload)</code> on each namespace covered by the convention but <code class="language-plaintext highlighter-rouge">reload("some.namespace")</code> does
<code class="language-plaintext highlighter-rouge">(require 'some.namespace :reload-all)</code> for an explicitly provided namespace).</p>

<h3 id="configuring-frameworkioclj">Configuring <code class="language-plaintext highlighter-rouge">framework.ioclj</code></h3>

<p>Since <code class="language-plaintext highlighter-rouge">ioclj.cfc</code> is a extension of <code class="language-plaintext highlighter-rouge">ioc.cfc</code> (DI/1), all of the <a href="using-di-one.html#configuration">same configuration options apply</a> as well as the following:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">boot</code> - string - default <code class="language-plaintext highlighter-rouge">""</code>. If you specify a non-empty value here, FW/1 will assume you want to use <strong>Boot</strong> instead of <strong>Leiningen</strong> and it wlil look for <code class="language-plaintext highlighter-rouge">build.boot</code> instead of <code class="language-plaintext highlighter-rouge">project.clj</code>. When a non-empty value is used here, the value of <code class="language-plaintext highlighter-rouge">lein</code> (below) is ignored.</li>
  <li><code class="language-plaintext highlighter-rouge">debug</code> - boolean - default <code class="language-plaintext highlighter-rouge">false</code>. If <code class="language-plaintext highlighter-rouge">true</code>, the CFML/Clojure bridge will write a lot of additional information to the server console (e.g., <code class="language-plaintext highlighter-rouge">catalina.out</code>),
which will help you check where FW/1 is looking for your Clojure files and which ones it may be ignoring (due to naming conventions not matching). Another
useful form of debugging is <code class="language-plaintext highlighter-rouge">&lt;cfdump var=#getBeanFactory().getBeanInfo()#"/&gt;</code> in a view so you can see all of the beans / namespaces that were found.</li>
  <li><code class="language-plaintext highlighter-rouge">lein</code> - string - default <code class="language-plaintext highlighter-rouge">"lein"</code>. Use this to specify the full file system path to your Leiningen shell/batch script if just the <code class="language-plaintext highlighter-rouge">lein</code> command on its
own won’t be found on the path used by your CFML server. At World Singles, we kept the Leiningen shell script under version control so we could
manage which version was used our applications, and we specified the path to that script, which was part of our application deployment, using the <code class="language-plaintext highlighter-rouge">lein</code>
configuration setting.</li>
  <li><code class="language-plaintext highlighter-rouge">server</code> - boolean - default <code class="language-plaintext highlighter-rouge">false</code>. By default, a new instance of the CFML/Clojure bridge CFC (<code class="language-plaintext highlighter-rouge">cfmljure.cfc</code>) is created every time the bean factory
(<code class="language-plaintext highlighter-rouge">ioclj.cfc</code>) is created. However, since this bridge <em>modifies the classpath of your server on the fly</em> – not just your application (because JVM settings
are per server instance, not per application instance) – it is a reasonable optimization to cache the bridge instance in <code class="language-plaintext highlighter-rouge">server</code> scope (since running
<code class="language-plaintext highlighter-rouge">lein classpath</code> or <code class="language-plaintext highlighter-rouge">boot show -C</code> can be slow). Specifying
<code class="language-plaintext highlighter-rouge">server : true</code> will tell <code class="language-plaintext highlighter-rouge">framework.ioclj</code> to perform that optimization for you. This will create <code class="language-plaintext highlighter-rouge">server.__cfmljure</code>, which will be reused each time
the bean factory is recreated, until the server is restarted, or you explicitly delete that variable. If you change the dependencies in <code class="language-plaintext highlighter-rouge">project.clj</code> or <code class="language-plaintext highlighter-rouge">build.boot</code>,
you will need to force the bridge instance to be recreated in order for those new dependencies to be picked up.</li>
  <li><code class="language-plaintext highlighter-rouge">timeout</code> - numeric - default <code class="language-plaintext highlighter-rouge">300</code>. This is the number of seconds that FW/1 will wait for the <code class="language-plaintext highlighter-rouge">lein classpath</code> or <code class="language-plaintext highlighter-rouge">boot show -C</code> command to execute at startup. This
should be sufficient even if you have a large number of dependencies in your <code class="language-plaintext highlighter-rouge">project.clj</code> or <code class="language-plaintext highlighter-rouge">build.boot</code>.</li>
</ul>

<p>In addition, the folder paths you provide are searched as follows:</p>

<ul>
  <li>No prefix: path is searched (recursively) for CFCs, path is checked for <code class="language-plaintext highlighter-rouge">project.clj</code> or <code class="language-plaintext highlighter-rouge">build.boot</code> (according to whether the <code class="language-plaintext highlighter-rouge">boot</code> configuration is omitted or present), path is checked for a <code class="language-plaintext highlighter-rouge">src</code> folder which is then searched (recursively) for Clojure files to manage and autowire into CFCs.</li>
  <li><code class="language-plaintext highlighter-rouge">clj:</code> prefix: path is checked for <code class="language-plaintext highlighter-rouge">project.clj</code> or <code class="language-plaintext highlighter-rouge">build.boot</code> (according to whether the <code class="language-plaintext highlighter-rouge">boot</code> configuration is omitted or present), path is checked for a <code class="language-plaintext highlighter-rouge">src</code> folder which is then searched (recursively) for Clojure files to manage and autowire into CFCs.</li>
  <li><code class="language-plaintext highlighter-rouge">cfml:</code> prefix: path is searched (recursively) for CFCs.</li>
</ul>

<p>If your Clojure build file is alongside your <code class="language-plaintext highlighter-rouge">src</code> folder, and all your CFCs are also in (subfolders of) that same location, you can specify just one folder path with no prefix. Otherwise you will need to specify the path(s) to your CFCs, the path to your Clojure build file, and the path to your Clojure <code class="language-plaintext highlighter-rouge">src</code> folders separately.</p>

<p>Example 1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>approot/
    controllers/
        ... CFCs ...
    model/
        ... CFCs ...
    project.clj
    src/
        ... Clojure source files ...
    test/
        ... Clojure test files ...
</code></pre></div></div>

<p>In this project, just supplying the path to <code class="language-plaintext highlighter-rouge">approot</code> is all you need: <code class="language-plaintext highlighter-rouge">ioclj</code> will find <code class="language-plaintext highlighter-rouge">project.clj</code> there as well as the <code class="language-plaintext highlighter-rouge">src</code> folder (which it will
recursively search for <code class="language-plaintext highlighter-rouge">.clj</code> files) and DI/1 will recursively search the whole thing for CFCs.</p>

<p>Example 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>approot/
    build.boot
    controllers/
        ... CFCs ...
    model/
        cfcs/
            ... CFCs ...
        src/
            ... Clojure source files ...
        test/
            ... Clojure test files ...
</code></pre></div></div>

<p>In this project, you can supply the path to <code class="language-plaintext highlighter-rouge">approot</code> and it will find <code class="language-plaintext highlighter-rouge">build.boot</code> (assuming you also specify <code class="language-plaintext highlighter-rouge">boot</code> in your configuration), and it will
recursively find all your CFCs, but if you want any Clojure code to be managed and injected, you’ll need to supply the path to <code class="language-plaintext highlighter-rouge">model</code> as well (where
<code class="language-plaintext highlighter-rouge">src</code> is) and because you don’t want DI/1 to search both locations for CFCs (because that path overlaps with part of the <code class="language-plaintext highlighter-rouge">approot</code> tree), you will want
to specify that is Clojure only:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diLocations : [ "/path/to/approot", "clj:/path/to/approot/model" ]
</code></pre></div></div>

<p>It would be better to be explicit about which paths are to be searched for what types of files:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diLocations : [
    "clj:/path/to/approot",             // build.boot location
    "clj:/path/to/approot/model",       // Clojure src location
    "cfml:/path/to/approot/model/cfcs", // Model CFCs
    "cfml:/path/to/approot/controllers" // Controller CFCs
]
</code></pre></div></div>

<p>As you can see, you can organize you CFML and Clojure source code – and your Clojure build file – however you like (modulo the <code class="language-plaintext highlighter-rouge">src</code> folder requirement
for Clojure) and still tell FW/1 exactly what you want it to do.</p>

<h2 id="what-is-ns-all-about">What is ns all about?</h2>

<p>Probably the most complex and confusing aspect when you are first learning Clojure is the <code class="language-plaintext highlighter-rouge">ns</code> expression. <code class="language-plaintext highlighter-rouge">ns</code> serves two main purposes:</p>

<ul>
  <li>It declares the namespace in which the code in a given file lives.</li>
  <li>It declares what additional namespaces you depend on and how you’re going to access functions in them.</li>
</ul>

<p>Think of a namespace as a “package” or “module”. The default convention in Clojure is that the namespace matches the filesystem path below your <code class="language-plaintext highlighter-rouge">src</code>
or <code class="language-plaintext highlighter-rouge">test</code> folder, except that <code class="language-plaintext highlighter-rouge">-</code> in a namespace identifier matches <code class="language-plaintext highlighter-rouge">_</code> in the file path. Technically, a namespace can be implemented across multiple
files but it isn’t very common to see that, so don’t worry about it.</p>

<p>In the <code class="language-plaintext highlighter-rouge">6helloclojure</code> example, you’ll see <code class="language-plaintext highlighter-rouge">hello.controllers.main</code> for <code class="language-plaintext highlighter-rouge">src/hello/controllers/main.clj</code> and <code class="language-plaintext highlighter-rouge">hello.controllers.main-test</code> for
<code class="language-plaintext highlighter-rouge">test/hello/controllers/main_test.clj</code>. If you follow this basic convention, you won’t go wrong. If your <code class="language-plaintext highlighter-rouge">ns</code> declaration doesn’t match the
filesystem path, you can get strange errors when you attempt to access it. Think of it much like the dotted-path used to access CFCs in CFML.</p>

<p>The second important part of <code class="language-plaintext highlighter-rouge">ns</code> is the list of namespaces your code <code class="language-plaintext highlighter-rouge">:require</code>s. There are two basic forms here:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">[some.namespace :as alias]</code> which lets you use <code class="language-plaintext highlighter-rouge">alias/name</code> as a way to reference any functions defined in <code class="language-plaintext highlighter-rouge">some.namespace</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">[some.namespace :refer [fn1 fn2]]</code> which lets you use <code class="language-plaintext highlighter-rouge">fn1</code> and <code class="language-plaintext highlighter-rouge">fn2</code> directly from <code class="language-plaintext highlighter-rouge">some.namespace</code> without a prefix. The
shorthand <code class="language-plaintext highlighter-rouge">:refer :all</code> brings in every function from that namespace, and is generally only used in test code.</li>
</ul>

<p>Prefer the first form – which you see in <code class="language-plaintext highlighter-rouge">hello.controllers.main</code> where <code class="language-plaintext highlighter-rouge">hello.services.greeter</code> is given an alias of <code class="language-plaintext highlighter-rouge">greet</code> so that
the controller can call <code class="language-plaintext highlighter-rouge">greet/hello</code>.</p>

<p>You’ll use the <code class="language-plaintext highlighter-rouge">:require</code> expression to bring in Clojure standard libraries, 3rd party Clojure libraries, and parts of your own code. For most
3rd party libraries, you’ll also need to add an entry to <code class="language-plaintext highlighter-rouge">:dependencies</code> in your <code class="language-plaintext highlighter-rouge">project.clj</code> file in order to tell <strong>Leiningen</strong> that you
need that library downloaded (or in your <code class="language-plaintext highlighter-rouge">build.boot</code> file for <strong>Boot</strong>). We’ll see this when we learn about database access below.</p>

<p>I recommend writing your required namespaces in alphabetical order – most production Clojure code relies on quite a long list of other namespaces
so organization is important.</p>

<p>You might think this sounds a bit like <code class="language-plaintext highlighter-rouge">import</code> statements in Java and you’d be right, except that <code class="language-plaintext highlighter-rouge">:require</code> is purely for Clojure code.
There is another form for importing Java classes, called <code class="language-plaintext highlighter-rouge">:import</code>, but Java interop is a whole other subject and you should consult a
Clojure book or the online documentation for more details about that.</p>

<h1 id="building-your-own-cfml--clojure-application">Building Your Own CFML / Clojure Application</h1>

<p>Since we want to focus on the Clojure aspect of a combined CFML / Clojure project, we’ll
start out by creating a Clojure project, and adding the necessary FW/1 CFML files to it
in order to create a web application.</p>

<p>We will build a very simple task manager, backed by a database. We will initially create
a CFML controller and write a Clojure service to interact with the database, then we’ll
replace the CFML controller with a Clojure controller to wrap things up.</p>

<p>We’ll assume you’re using <strong>Leiningen</strong> for this exercise. <em>I may update this section
with instructions for <strong>Boot</strong> once project templates are avaialble for that tool.</em></p>

<h2 id="creating-the-clojure-project">Creating the Clojure project</h2>

<p>Our Clojure code doesn’t need to be in our CFML webroot so just pick a folder and we’ll create a new Clojure application, in which we’ll write our task manager code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lein new app taskmanager
</code></pre></div></div>

<p>This will create a folder called <code class="language-plaintext highlighter-rouge">taskmanager</code> containing a bare bones Clojure project. It’ll have a <code class="language-plaintext highlighter-rouge">-main</code> function so we can use it to run specific operations from the command line, and it’ll have tests we can run to validate our code.</p>

<h2 id="accessing-a-database-from-clojure">Accessing a Database from Clojure</h2>

<p>In order to access a database (via JDBC) from Clojure, you will first need to update your <code class="language-plaintext highlighter-rouge">project.clj</code> file to include
dependencies on Clojure’s JDBC library and what your choice of JDBC driver is. For now we’ll use Apache Derby but if you
look at the <a href="https://github.com/clojure/java.jdbc">java.jdbc</a> page on GitHub, you’ll see links to several other common
database drivers (if you use SQL Server, you’ll find it easiest to use the jTDS driver to get started!).</p>

<p>Edit <code class="language-plaintext highlighter-rouge">project.clj</code> and update the <code class="language-plaintext highlighter-rouge">:dependencies</code> section to include:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[cfml-interop "0.2.0"]
[org.apache.derby/derby "10.11.1.1"]
[org.clojure/java.jdbc "0.4.1"]
</code></pre></div></div>

<p>You’ll now have a vector with four vectors inside it like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>:dependencies [[cfml-interop "0.2.0"]
               [org.apache.derby/derby "10.11.1.1"]
               [org.clojure/java.jdbc "0.4.1"]
               [org.clojure/clojure "1.8.0"]]
</code></pre></div></div>

<p><em>Note: if the last vector has <code class="language-plaintext highlighter-rouge">org.clojure/clojure "1.6.0"</code>, you must update it to use <code class="language-plaintext highlighter-rouge">"1.8.0"</code> instead!</em></p>

<p>The first entry is the open source version of the CFML / Clojure interop library we use at World Singles.
The second entry is the JDBC driver for Apache Derby.
The third entry is Clojure’s core JDBC library.
The fourth entry is the Clojure language and core functions.</p>

<p>Now run <code class="language-plaintext highlighter-rouge">lein repl</code> and we can try this out. As the REPL starts up, it will download the new
libraries and then you’ll get the prompt. Let’s create test database and write and read some
data with it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>taskmanager.core&gt; (require '[clojure.java.jdbc :as sql])
nil ;; now we have the JDBC library loaded with an alias
taskmanager.core&gt; (def db {:dbtype "derby" :dbname "/path/to/clojure/taskmanager/cfmltest" :create true})
#'user/db ;; this is our database spec -- adjust the path accordingly!
user=&gt; (sql/execute! db [(str "CREATE TABLE task ("
  "id INT GENERATED ALWAYS AS IDENTITY,"
  "task VARCHAR(32),"
  "done BOOLEAN DEFAULT false"
  ")")])
[0] ;; success! we created the task table
taskmanager.core&gt; (sql/insert! db :task {:task "Test database"})
({:1 1M}) ;; the sequence of inserted keys:
;; there is just one key, labeled :1, with the value 1
;; the M indicates a BigDecimal value
taskmanager.core&gt; (sql/insert! db :task {:task "Read some data"})
({:1 2M}) ;; generated key is 2 this time
taskmanager.core&gt; (sql/query db ["SELECT * FROM task WHERE NOT done"])
({:done false, :task "Test database", :id 1} {:done false, :task "Read some data", :id 2})
;; our two records came back, let's update one
taskmanager.core&gt; (sql/update! db :task {:done true} ["id = ?" 1])
(1) ;; one row was updated
taskmanager.core&gt; (sql/query db ["SELECT * FROM task WHERE NOT done"])
({:done false, :task "Read some data", :id 2})
;; yup, that's our only task not done now
taskmanager.core&gt; (sql/update! db :task {:done true} ["id = ?" 2])
(1) ;; one row was updated
;; let's delete our table to clean up
taskmanager.core&gt; (sql/execute! db [ "DROP TABLE task"])
[0] ;; success! we dropped the table
</code></pre></div></div>

<p>Press control-d to exit the REPL.</p>

<p>Some notes on the syntax:</p>

<ul>
  <li>Functions that modify the database end in <code class="language-plaintext highlighter-rouge">!</code> to indicate they have side effects</li>
  <li>SQL and any parameters are specified together in a vector:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">["a SQL string" param1 param2 param3]</code></li>
      <li>Use <code class="language-plaintext highlighter-rouge">?</code> in the SQL string to indicate a parameter placeholder</li>
      <li>A <code class="language-plaintext highlighter-rouge">PreparedStatement</code> is used for all operations (which, together with using <code class="language-plaintext highlighter-rouge">?</code>, protects you from SQL injection attacks)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">execute!</code> can be used for arbitrary SQL or DDL</li>
  <li><code class="language-plaintext highlighter-rouge">query</code> is intended for <code class="language-plaintext highlighter-rouge">SELECT</code> only and returns a result set</li>
  <li><code class="language-plaintext highlighter-rouge">insert!</code> inserts a new row from a hash map (struct)</li>
  <li><code class="language-plaintext highlighter-rouge">update!</code> sets the column values shown in the hash map for all rows that match the <code class="language-plaintext highlighter-rouge">WHERE</code> clause provided in the vector, so it is shorthand for <code class="language-plaintext highlighter-rouge">["UPDATE table SET col1 = ?, col2 = ?, col3 = ? WHERE clause" param1 param2 param3]</code></li>
</ul>

<h2 id="adding-the-initial-cfml-files">Adding the initial CFML files</h2>

<p>We’re going to put our CFML files in a folder somewhere in our webroot, e.g., a <code class="language-plaintext highlighter-rouge">taskmanager</code> folder. We’ll need <code class="language-plaintext highlighter-rouge">Application.cfc</code> and an empty <code class="language-plaintext highlighter-rouge">index.cfm</code>.
Here’s what needs to be in our <code class="language-plaintext highlighter-rouge">Application.cfc</code> file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>component extends=framework.one {
    variables.framework = {
        diComponent : "framework.ioclj",
        diLocations : "/path/to/clojure/taskmanager"
    };
    function setupRequest() {
        // reload Clojure when FW/1 is reloaded:
        if ( isFrameworkReloadRequest() ) {
            getBeanFactory().reload( "all" );
        }
    }
}
</code></pre></div></div>

<p>We need to tell FW/1 to use the <code class="language-plaintext highlighter-rouge">ioclj</code> extension to DI/1, and we need to tell it the full path to the Clojure code (the folder where our <code class="language-plaintext highlighter-rouge">project.clj</code> lives).
We also add the code to programmatically reload our Clojure files, in <code class="language-plaintext highlighter-rouge">setupRequest()</code>.</p>

<p>Then we need a default <code class="language-plaintext highlighter-rouge">main.default</code> view so we can test the app:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!--- views/main/default.cfm ---&gt;
Hello, World!
</code></pre></div></div>

<p>If this loads without error, FW/1 has successfully located your Clojure project and loaded it.</p>

<h2 id="writing-a-clojure-service">Writing a Clojure Service</h2>

<p>We’ll start by writing a simple service containing just a single function so we can check that FW/1 finds and loads it correctly and that we can access it from our view.
In your <code class="language-plaintext highlighter-rouge">taskmanager</code> Clojure folder, create a <code class="language-plaintext highlighter-rouge">services</code> subfolder under <code class="language-plaintext highlighter-rouge">src/taskmanager</code> and then create this <code class="language-plaintext highlighter-rouge">greeting.clj</code> file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>;; src/taskmanager/services/greeting.clj
(ns taskmanager.services.greeting)

(defn hello [name] (str "Hello, " name "!"))
</code></pre></div></div>

<p>Now we’ll update our <code class="language-plaintext highlighter-rouge">main.default</code> view to look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;cfoutput&gt;
  #getBeanFactory().getBean("greetingService").hello( "Clojure" )#
&lt;/cfoutput&gt;
</code></pre></div></div>

<p>If you just try to hit the taskmanager app in your browser, you’ll get an error that <code class="language-plaintext highlighter-rouge">greetingService</code> does not exist. You need to reload FW/1 (via adding <code class="language-plaintext highlighter-rouge">?reload=true</code> to the URL)
so that it will reload the bean factory and find our newly created Clojure service. If you do that, you should see <code class="language-plaintext highlighter-rouge">Hello, Clojure!</code> in your browser.</p>

<p>Now we can get to work writing our simple task manager service!</p>

<p>We already wrote most of the code we need, as part of our REPL session above, and if you look in that <code class="language-plaintext highlighter-rouge">taskmanager</code> folder, you’ll find a (hidden) file called <code class="language-plaintext highlighter-rouge">.lein-repl-history</code> which contains the code you typed in.
We’re going to use that as the basis of our service. Let’s create <code class="language-plaintext highlighter-rouge">task.clj</code> in our <code class="language-plaintext highlighter-rouge">services</code> folder like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>;; src/taskmanager/services/task.clj
(ns taskmanager.services.task
  (:require [clojure.java.jdbc :as sql]))

;; for now we'll just hard-code one database spec but
;; we could pass it in from our controller as needed
(def db {:dbtype "derby" :dbname "cfmltest" :create true})

(defn create-task-table []
  (sql/execute! db [(str "CREATE TABLE task ("
                         "id INT GENERATED ALWAYS AS IDENTITY,"
                         "task VARCHAR(32),"
                         "done BOOLEAN DEFAULT false"
                         ")")]))

(defn add-task
  "Given a task name, add it to our database and return the new row's ID."
  [task]
  (-&gt; (sql/insert! db :task {:task task}) first :1))

(defn complete-task
  "Given a task ID, mark it as done and return the number of rows updated."
  [id]
  (-&gt; (sql/update! db :task {:done true} ["id = ?" id]) first))

(defn task-list
  "Return the tasks.
  If all is true, return all tasks, else just the incomplete ones."
  [all]
  (sql/query db [(str "SELECT * FROM task"
                      (when-not all " WHERE NOT done"))]))
</code></pre></div></div>

<p>You can try out each function in the REPL or you can write unit tests, but they’re all fairly simple and we “tested” them when we were exploring how
to work with a database in the REPL earlier.</p>

<h2 id="fleshing-out-the-views">Fleshing out the Views</h2>

<p>Next we’ll create the views we need for our simple task manager. The default view will show a list of tasks with options to:</p>

<ul>
  <li>List all / outstanding tasks</li>
  <li>Add a new task</li>
  <li>Next to each task, the status, and the ability to mark a task as complete</li>
</ul>

<p>We’ll reuse <code class="language-plaintext highlighter-rouge">main.default</code> as our list view and add <code class="language-plaintext highlighter-rouge">main.newtask</code> for adding new tasks. We’ll additionally have actions for <code class="language-plaintext highlighter-rouge">main.addtask</code> and <code class="language-plaintext highlighter-rouge">main.completetask</code> which will both
redirect to <code class="language-plaintext highlighter-rouge">main.default</code>. We’ll have an optional boolean argument to <code class="language-plaintext highlighter-rouge">main.default</code> which will specify showing all tasks or just outstanding tasks.</p>

<p>Here’s our <code class="language-plaintext highlighter-rouge">main.default</code> view:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!--- views/main/default.cfm ---&gt;
&lt;cfparam name="rc.all" default="false"/&gt;
&lt;cfoutput&gt;
    &lt;p&gt;
        &lt;cfif rc.all&gt;
            &lt;a href="#buildURL( 'main.default?all=false' )#"&gt;List To-Do&lt;/a&gt;
        &lt;cfelse&gt;
            &lt;a href="#buildURL( 'main.default?all=true' )#"&gt;List All&lt;/a&gt;
        &lt;/cfif&gt;
        |
        &lt;a href="#buildURL( 'main.newtask' )#"&gt;Add New Task&lt;/a&gt;
    &lt;/p&gt;
    &lt;cfif arrayLen( rc.tasks )&gt;
        &lt;ul&gt;
            &lt;cfloop index="task" array="#rc.tasks#"&gt;
                &lt;li&gt;
                    &lt;form action="#buildURL( 'main.completetask' )#" method="post"&gt;
                        #task.task#
                        &lt;cfif !task.done&gt;
                            &lt;input type="hidden" name="id" value="#task.id#"/&gt;
                            &lt;input type="submit" value="Done!"/&gt;
                        &lt;/cfif&gt;
                    &lt;/form&gt;
                &lt;/li&gt;
            &lt;/cfloop&gt;
        &lt;/ul&gt;
    &lt;cfelse&gt;
        &lt;p&gt;You have nothing to do!&lt;/p&gt;
    &lt;/cfif&gt;
&lt;/cfoutput&gt;
</code></pre></div></div>

<p>Here’s our <code class="language-plaintext highlighter-rouge">main.newtask</code> view:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!--- views/main/newtask.cfm ---&gt;
&lt;cfoutput&gt;
    &lt;form action="#buildURL( 'main.addtask' )#" method="post"&gt;
        &lt;p&gt;
            Task:
            &lt;input name="task" type="text"/&gt;
            &lt;input type="submit" value="Add!"/&gt;
        &lt;/p&gt;
    &lt;/form&gt;
    &lt;p&gt;&lt;a href="#buildURL( 'main.default' )#"&gt;Cancel&lt;/a&gt;&lt;/p&gt;
&lt;/cfoutput&gt;
</code></pre></div></div>

<h2 id="testing-with-a-cfml-controller">Testing with a CFML Controller</h2>

<p>We’ll add a dummy controller so we can test this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// controllers/main.cfc
component accessors=true {
    property framework;
    function default( rc ) {
        rc.tasks = [ ];
    }
    function addtask( rc ) {
        framework.redirect( 'main.default' );
    }
    function completetask( rc ) {
        framework.redirect( 'main.default' );
    }
}
</code></pre></div></div>

<p>If we hit the app in our browser with <code class="language-plaintext highlighter-rouge">?reload=true</code> in the URL, you should see:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>List All | Add New Task

You have nothing to do!
</code></pre></div></div>

<p>If you click <code class="language-plaintext highlighter-rouge">Add New Task</code> and fill in the form and click <code class="language-plaintext highlighter-rouge">Add!</code>, you’ll end up back on this page with no tasks listed.</p>

<h3 id="using-the-clojure-service">Using the Clojure Service</h3>

<p>Now we’ll wire in our Clojure service that we wrote above and make something useful happen!</p>

<p>We’ll change our controller to look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// controllers/main.cfc
component accessors=true {
    property framework;
    property taskService; // add this
    function default( rc ) {
        // default rc.all and pass boolean to Clojure:
        param name="rc.all" default="false";
        rc.tasks = taskService.task_list( rc.all ? true : false );
    }
    function addtask( rc ) {
        // call Clojure
        taskService.add_task( rc.task );
        framework.redirect( 'main.default' );
    }
    function completetask( rc ) {
        // call Clojure
        taskService.complete_task( rc.id );
        framework.redirect( 'main.default' );
    }
}
</code></pre></div></div>

<p><em>Note: because URL and form values come into CFML as strings that it will automatically coerce to numeric, boolean, etc, we need to explicitly pass either <code class="language-plaintext highlighter-rouge">true</code>
or <code class="language-plaintext highlighter-rouge">false</code> to <code class="language-plaintext highlighter-rouge">taskService.task_list()</code> which is why we write <code class="language-plaintext highlighter-rouge">rc.all ? true : false</code>. Most languages do not have CFML’s flexibility when interpreting data, but
they also provide a lot more type safety! You might wonder why we don’t convert <code class="language-plaintext highlighter-rouge">rc.id</code> to numeric in the call to <code class="language-plaintext highlighter-rouge">taskService.complete_task()</code>? We can get away
with it there because it’s passed directly to the JDBC driver and that knows that the <code class="language-plaintext highlighter-rouge">id</code> field is numeric and it will parse the string for you. In general,
you probably shouldn’t rely on that and should explicitly convert your inbound string data from <code class="language-plaintext highlighter-rouge">rc</code> to the type your Clojure code is expecting.</em></p>

<p>If we run this (with <code class="language-plaintext highlighter-rouge">?reload=true</code> in the URL), we’ll probably get a SQL exception because our table doesn’t exist. We dropped the table at the end
of our REPL session (unless you recreated it again while testing the <code class="language-plaintext highlighter-rouge">task.clj</code> service?).</p>

<p>Let’s make our controller automatically create the table if the task list fails:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    function default( rc ) {
        // default rc.all and pass boolean to Clojure:
        param name="rc.all" default="false";
        try {
            rc.tasks = taskService.task_list( rc.all ? true : false );
        } catch ( any e ) {
            taskService.create_task_table();
            rc.tasks = taskService.task_list( rc.all ? true : false );
        }
    }
</code></pre></div></div>

<p>Run it again (with <code class="language-plaintext highlighter-rouge">?reload=true</code>) and you should see an empty list of tasks. Add a new task and… oh dear! We got an exception:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Key [TASK] doesn't exist in Map (clojure.lang.PersistentArrayMap)
</code></pre></div></div>

<p>The reason for this is that raw Clojure structs (hashmaps) are not quite compatible with CFML structs (because they use keywords as keys,
whereas CFML uses case-insensitive strings). The Clojure integration provides a way to convert back and forth, so we’ll need our
controller to depend on <code class="language-plaintext highlighter-rouge">cfmljure</code>, and then we’ll use <code class="language-plaintext highlighter-rouge">toCFML()</code> to convert the Clojure data structure
to a CFML-compatible data structure so we can display it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// controllers/main.cfc
component accessors=true {
    property framework;
    property taskService;
    property cfmljure; // add this
    function default( rc ) {
        param name="rc.all" default="false";
        try {
            rc.tasks = taskService.task_list( rc.all ? true : false );
        } catch ( any e ) {
            taskService.create_task_table();
            rc.tasks = taskService.task_list( rc.all ? true : false );
        }
        rc.tasks = cfmljure.toCFML( rc.tasks ); // make it CFML-compatible
    }
    ...
}
</code></pre></div></div>

<p><em>Note: if you don’t add the <code class="language-plaintext highlighter-rouge">cfml-interop</code> dependency to a project, the <code class="language-plaintext highlighter-rouge">toCFML()</code> and <code class="language-plaintext highlighter-rouge">toClojure()</code> functions available in
<strong>cfmljure</strong> will still “work” but the struct keys will be case-sensitive and <strong>lowercase</strong> so you would need to use <code class="language-plaintext highlighter-rouge">myStruct['key']</code>
notation to access them instead of just <code class="language-plaintext highlighter-rouge">myStruct.key</code>.</em></p>

<h2 id="writing-a-clojure-controller">Writing a Clojure Controller</h2>

<p>In this final section of <strong>Building Your Own CFML / Clojure Application</strong>, we’re going to replace our CFML Controller with an equivalent Clojure
Controller. In your Clojure <code class="language-plaintext highlighter-rouge">taskmanager</code> project, create a <code class="language-plaintext highlighter-rouge">src/taskmanager/controllers/</code> folder and inside it create <code class="language-plaintext highlighter-rouge">main.clj</code> containing:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>;; src/taskmanager/controllers/main.clj
(ns taskmanager.controllers.main
  (:require [cfml.coerce :refer [-&gt;boolean]
            [taskmanager.services.task :as task]))

(defn default [rc]
  (let [all? (-&gt;boolean (:all rc))
        tasks (try
                (task/task-list all?)
                (catch Exception _
                  (task/create-task-table)
                  (task/task-list all?)))]
    (assoc rc :tasks tasks)))

(defn addtask [rc]
  (task/add-task (:task rc))
  (assoc rc :redirect {:action "main.default"}))

(defn completetask [rc]
  (task/complete-task (:id rc))
  (assoc rc :redirect {:action "main.default"}))
</code></pre></div></div>

<p>This is the equivalent of our CFML controller above so let’s walk through each piece of it:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">(ns ...)</code> specifies <code class="language-plaintext highlighter-rouge">taskmanager.controllers.main</code> as our namespace and makes our service available with the <code class="language-plaintext highlighter-rouge">task</code> alias.</li>
  <li><code class="language-plaintext highlighter-rouge">default</code> does the following:
    <ol>
      <li>binds <code class="language-plaintext highlighter-rouge">all?</code> to the boolean value of <code class="language-plaintext highlighter-rouge">rc.all</code> (which comes in as the string <code class="language-plaintext highlighter-rouge">"true"</code> or <code class="language-plaintext highlighter-rouge">"false"</code>!).</li>
      <li>binds <code class="language-plaintext highlighter-rouge">tasks</code> to the result of calling <code class="language-plaintext highlighter-rouge">task-list</code> in our service (including catching any exception, attempting to create the task table, and calling <code class="language-plaintext highlighter-rouge">task-list</code> again – <code class="language-plaintext highlighter-rouge">try</code>/<code class="language-plaintext highlighter-rouge">catch</code> is an expression in Clojure that returns a value, just like any other expression).</li>
      <li>returns <code class="language-plaintext highlighter-rouge">rc</code> with the task list added (as <code class="language-plaintext highlighter-rouge">rc.tasks</code>).</li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">addtask</code> calls <code class="language-plaintext highlighter-rouge">add-task</code> in our service and returns <code class="language-plaintext highlighter-rouge">rc</code> with a redirect added to it.</li>
  <li><code class="language-plaintext highlighter-rouge">completetask</code> calls <code class="language-plaintext highlighter-rouge">complete-task</code> in our service and returns <code class="language-plaintext highlighter-rouge">rc</code> with a redirect added to it.</li>
</ol>

<p>Now run this with <code class="language-plaintext highlighter-rouge">?reload=true</code> in the URL and it should work just as it did before, except now it’s using the Clojure controller instead of the CFML controller!
How do you know it’s using the Clojure version? Because <code class="language-plaintext highlighter-rouge">framework.ioclj</code> adds the Clojure namespaces it finds after any CFCs it finds, overwriting any beans
with the same alias. If you want to convince yourself, remove <code class="language-plaintext highlighter-rouge">controllers/main.cfc</code> from your <code class="language-plaintext highlighter-rouge">taskmanager</code> folder in the webroot, and reload the application again.</p>

<p>So why would we write our controllers in Clojure instead of CFML?</p>

<ul>
  <li>As simple functions (that take <code class="language-plaintext highlighter-rouge">rc</code> as input and produce an updated <code class="language-plaintext highlighter-rouge">rc</code> as output), they’re easy to write unit tests for.</li>
  <li>You don’t need to convert <code class="language-plaintext highlighter-rouge">rc</code> data structures back and forth between CFML and Clojure since that’s taken care of automatically in FW/1 (technically in <code class="language-plaintext highlighter-rouge">cljcontroller.cfc</code>).</li>
  <li>You can work in the REPL building and testing your entire application’s functionality (and then work on the views with a browser).</li>
  <li>We get the full power of Clojure’s data abstractions, concurrency, and immutability working for us.</li>
  <li>With your services and controllers in Clojure, you’re one step away from building all-Clojure web applications using <a href="https://github.com/framework-one/fw1-clj">FW/1 for Clojure</a>.</li>
</ul>

<h3 id="rc-value-conversion">RC Value Conversion</h3>

<p>Since all values come into the <code class="language-plaintext highlighter-rouge">rc</code> (from URL and form scope) as strings, you’ll usually need to convert them to the appropriate numeric, boolean,
or other data type in order to use them in your Clojure code. We saw above that you can get away with some things, but in the pure Clojure world,
you need to be much more specific about types.</p>

<p>The <a href="https://github.com/seancorfield/cfml-interop"><code class="language-plaintext highlighter-rouge">cfml-interop</code> library</a>, containing the <code class="language-plaintext highlighter-rouge">cfml.interop</code> namespace, contains some useful functions for converting from string to various types - the <code class="language-plaintext highlighter-rouge">-&gt;type</code> naming is just a convention in Clojure for conversion
functions:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-&gt;long</code> – Accepts any value, string or numeric, and tries to convert it to a <code class="language-plaintext highlighter-rouge">Long</code> value. You can provide a second argument which specifies the default to return if conversion fails (otherwise it will return <code class="language-plaintext highlighter-rouge">0</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">-&gt;double</code> – Accepts any value, string or numeric, and tries to convert it to a <code class="language-plaintext highlighter-rouge">Double</code> value. You can provide a second argument which specifies the default to return if conversion fails (otherwise it will return <code class="language-plaintext highlighter-rouge">0.0</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">-&gt;boolean</code> – Accepts any value, boolean, string or numeric, and tries to convert it to a <code class="language-plaintext highlighter-rouge">Boolean</code> value. You can provide a second argument which specifies the default to return if conversion fails (otherwise it will return <code class="language-plaintext highlighter-rouge">false</code>). This treats the strings <code class="language-plaintext highlighter-rouge">"true"</code> and <code class="language-plaintext highlighter-rouge">"yes"</code> as <code class="language-plaintext highlighter-rouge">true</code> (not case sensitive), as well as treating non-zero numeric values as <code class="language-plaintext highlighter-rouge">true</code> (and zero as <code class="language-plaintext highlighter-rouge">false</code>), just like CFML.</li>
</ul>

<h3 id="augmenting-rc-with-clojure-expressions">Augmenting RC With Clojure Expressions</h3>

<p>Normally <code class="language-plaintext highlighter-rouge">rc</code> is automatically converted back and forth between a CFML “struct” and a Clojure hash map so that inside Clojure controllers, the keys are lowercase keywords (as expected in Clojure). This automatic conversion handles “regular” data types just fine but there may be times when you want to pass more complex data into Clojure controllers, such as a <code class="language-plaintext highlighter-rouge">Component</code> providing the application’s configuration or state. The <code class="language-plaintext highlighter-rouge">cljcontroller.cfc</code> file provides an extension point for this – <code class="language-plaintext highlighter-rouge">callClojure()</code> – to allow you to add Clojure expressions to the request context (after conversion), before calling the actual controller (and then removing them again before returning to CFML). Write a CFC that extends <code class="language-plaintext highlighter-rouge">framework.cljcontroller</code> and overrides <code class="language-plaintext highlighter-rouge">callClojure()</code>. Make sure to call <code class="language-plaintext highlighter-rouge">super.callClojure()</code>. Then tell DI/1 that <code class="language-plaintext highlighter-rouge">cljcontroller</code> is your CFC instead:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// myapp/cljcontroller.cfc:
component extends=framework.cljcontroller {

    // add/remove application.clojure_component to the request context
    // this is a Clojure Component (Stuart Sierra's "reloaded" workflow)
    // and is not convertible to/from CFML -- note that rcClj is a Clojure
    // hash map at this point so you must use Clojure functions to manipulate it
    function callClojure( string qualifiedName, any rcClj ) {
        var core = variables.cfmljure.clojure.core;
        var appComponent = core.keyword( "application-component" );
        rcClj = core.assoc( rcClj, appComponent, application.clojure_component );
        var rawResult = super.callClojure( qualifiedName, rcClj );
        return core.dissoc( rawResult, appComponent );
    }

}

// framework configuration:
            diConfig : {
                ...
                cljcontroller : "myapp.cljcontroller",
                ...
            },

</code></pre></div></div>

<h1 id="a-clojure-primer">A Clojure Primer</h1>

<p>To learn about Clojure in any depth, I’d recommend you go through the <strong><a href="#more-stuff-to-read">More Stuff to Read</a></strong> section at the end of this
page, but I’m going to give you a quick run through of some useful basics that should get you up and running more quickly.</p>

<p>As I claimed earlier, Clojure is a very simple language with only a few pieces of syntax:</p>

<ul>
  <li>A semicolon introduces a comment. Typically a single semicolon <code class="language-plaintext highlighter-rouge">;</code> is used for an end of line comment and a double semicolon <code class="language-plaintext highlighter-rouge">;;</code> is used for
a whole line comment.</li>
  <li><code class="language-plaintext highlighter-rouge">(func arg1 arg2 arg3)</code> represents a function call (with three arguments). You can use commas if you want but they are
just whitespace: <code class="language-plaintext highlighter-rouge">(func arg1, arg2, arg3)</code>. Most Clojure developers omit commas in function calls. Almost everything in Clojure is a function call.
A few things that look like function calls are actually “<a href="http://clojure.org/special_forms">special forms</a>” but you can pretend they’re really function calls
until you get a bit more proficient (a function call evaluates all its arguments before the call, a special form may not
evaluate its arguments until it needs them).</li>
  <li><code class="language-plaintext highlighter-rouge">a</code> is a symbol – a variable or function name – that evaluates to whatever it has been bound to. See <code class="language-plaintext highlighter-rouge">def</code>, <code class="language-plaintext highlighter-rouge">defn</code> and <code class="language-plaintext highlighter-rouge">let</code> below.</li>
  <li><code class="language-plaintext highlighter-rouge">:a</code> is a keyword – it evaluates to itself – that is a bit like a string except it is cached (so two <code class="language-plaintext highlighter-rouge">:a</code>s in different parts of
your code are the exact same thing and can be compared for identity based on their address, not their value). Keywords are commonly
used as the keys in a hash map (see below).</li>
  <li><code class="language-plaintext highlighter-rouge">[1 2 3 4]</code> represents a vector (array) with the specified elements. You can use commas if you want, but they are just whitespace:
<code class="language-plaintext highlighter-rouge">[1, 2, 3, 4]</code>. Most Clojure developers omit commas in vectors.</li>
  <li><code class="language-plaintext highlighter-rouge">{:a 1, :b 2, :c 3}</code> represents a hash map (struct) with keys <code class="language-plaintext highlighter-rouge">:a</code>, <code class="language-plaintext highlighter-rouge">:b</code>, <code class="language-plaintext highlighter-rouge">:c</code> and values <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code> respectively. The commas
are just whitespace but some Clojure developers use them anyway to clearly delineate pairs.</li>
  <li><code class="language-plaintext highlighter-rouge">#{1 2 3}</code> represents a set of values. If you add <code class="language-plaintext highlighter-rouge">4</code> to that set you get <code class="language-plaintext highlighter-rouge">#{1 2 3 4}</code> but if you add <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, or <code class="language-plaintext highlighter-rouge">3</code> to it, it remains
unchanged because those values are already in the set. CFML doesn’t have a set data type, but you might simulate it with a struct whose
values are <code class="language-plaintext highlighter-rouge">true</code> (or some other arbitrary value) and the presence or absence of a key says whether it’s in the set or not.</li>
</ul>

<p>That’s about it. When you learn about macros (in one of the Clojure books), you’ll encounter a few new pieces of syntax but you
don’t need that to get going.</p>

<h2 id="some-basic-clojure-functions">Some Basic Clojure Functions</h2>

<p>Functions all the way down. Some functions / special forms are very important so I’m going to go through some of those here.</p>

<h3 id="def-fn-and-defn"><code class="language-plaintext highlighter-rouge">def</code>, <code class="language-plaintext highlighter-rouge">fn</code>, and <code class="language-plaintext highlighter-rouge">defn</code></h3>

<p>The <code class="language-plaintext highlighter-rouge">def</code> special form creates a global (top-level) binding of a name to a value within the current namespace:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(def a 42)
;; binds a to the value 42 -- technically a is a Var
a
;; produces 42
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">fn</code> special form creates an anonymous function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(fn [a b c] (* a b c))
;; creates a function with three arguments a, b, and c
;; that multiplies those three values together
</code></pre></div></div>

<p>Anonymous functions are often used as arguments to other functions:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(map (fn [x] (* x 2)) [1 2 3 4 5])
;; produces (2 4 6 8 10)
</code></pre></div></div>

<p>Strictly speaking, a function can contain more than one expression: they are all evaluated in order, but only the value of the last
expression is returned. The others are thrown away. So why have multiple expressions? You might have some operations that cause side
effects, such as logging to file or writing to a database, and you want to evaluate those for their effects but not necessarily
their result.</p>

<p>You can bind a name to an anonymous function, to create a named function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(def twice (fn [x] (* x 2)))
</code></pre></div></div>

<p>This is so common that <code class="language-plaintext highlighter-rouge">defn</code> exists as a shorthand for it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn twice [x] (* x 2))
</code></pre></div></div>

<p>Documentation is built into Clojure and you can (and should) provide a “docstring” for all your functions that say what they do
and possibly provide example usage:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn twice "Doubles its argument." [x] (* x 2))
</code></pre></div></div>

<p>You’ll often see this written on multiple lines like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn sum-of-squares
  "Given two values, return the sum of their squares."
  [a b]
  (+ (* a a) (* b b)))
</code></pre></div></div>

<p>It’s common for functions to have short argument names because each function should be very short and simple, and the function names should
be descriptive.</p>

<p>The docstring – and the source code – of functions is available in the REPL (and in any Clojure editor that supports live evaluation) through
the <code class="language-plaintext highlighter-rouge">doc</code> – and <code class="language-plaintext highlighter-rouge">source</code> – functions (in the <code class="language-plaintext highlighter-rouge">clojure.repl</code> namespace). This makes it very easy to experiment with new libraries since all
of the documentation and source code is right there at your fingertips!</p>

<h3 id="if-when-and-do"><code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">when</code>, and <code class="language-plaintext highlighter-rouge">do</code></h3>

<p>In CFML we have an <code class="language-plaintext highlighter-rouge">if</code> statement. If the condition is true, the first group of statements is executed, else the second group of statements
is executed. In functional languages like Clojure, <code class="language-plaintext highlighter-rouge">if</code> is an expression (a special form) and it takes a condition and two expressions.
If the condition is true, the first expression is evaluated, else the second expression is evaluated. It’s more like the ternary operator
<code class="language-plaintext highlighter-rouge">? :</code> in CFML.</p>

<p>Also, it’s important to note that Clojure has strong views on what is true and false. You’ll hear of “truthy” and “falsey” in the Clojure
world because Clojure treats everything as true except for <code class="language-plaintext highlighter-rouge">false</code> and <code class="language-plaintext highlighter-rouge">nil</code>. In particular, that means that <code class="language-plaintext highlighter-rouge">0</code> is true, unlike in CFML.
The reason for this is an idiom called “nil punning”: it’s common for Clojure functions to return <code class="language-plaintext highlighter-rouge">nil</code> for “no such value” instead of
throwing an exception, and allowing <code class="language-plaintext highlighter-rouge">nil</code> to mean false makes it easy to test for such things:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(if (:name rc) (str "Hello " (:name rc) "!") "Who?")
</code></pre></div></div>

<p>In CFML, if you did <code class="language-plaintext highlighter-rouge">rc.name</code> and it wasn’t present, you’d get an exception. In Clojure, <code class="language-plaintext highlighter-rouge">(:name rc)</code> simple returns <code class="language-plaintext highlighter-rouge">nil</code> if there’s no
such key and you just test for that. You can prevent repetition of <code class="language-plaintext highlighter-rouge">(:name rc)</code> with <code class="language-plaintext highlighter-rouge">if-let</code> – see below.</p>

<p>If you don’t have an “else” expression (and want to return <code class="language-plaintext highlighter-rouge">nil</code> instead), use <code class="language-plaintext highlighter-rouge">when</code> instead of <code class="language-plaintext highlighter-rouge">if</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(when (:name rc) (str "Hello " (:name rc) "!"))
</code></pre></div></div>

<p>If the condition is “falsey”, you get <code class="language-plaintext highlighter-rouge">nil</code> back. Be aware that <code class="language-plaintext highlighter-rouge">when</code> allows multiple expressions, just like <code class="language-plaintext highlighter-rouge">fn</code> above and <code class="language-plaintext highlighter-rouge">let</code> below, and it evaluates
all of them but only returns the value of the last expression.</p>

<p>If you want to evaluate multiple expressions in an <code class="language-plaintext highlighter-rouge">if</code>, you need <code class="language-plaintext highlighter-rouge">do</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(if some-condition
  (do
    (log-something)
    (update-the-database)
    "Result!")
  "Failure!")
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">do</code> can be used where any single expression is accepted and behaves like the body of <code class="language-plaintext highlighter-rouge">fn</code>.</p>

<p>It might not surprise you to learn that <code class="language-plaintext highlighter-rouge">when</code> is really defined in terms of <code class="language-plaintext highlighter-rouge">if</code> and <code class="language-plaintext highlighter-rouge">do</code> something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(when condition expr1 expr2 expr3)
;; is treated like
(if condition (do expr1 expr2 expr3) nil)
</code></pre></div></div>

<h3 id="let-and-its-cousins"><code class="language-plaintext highlighter-rouge">let</code> and its cousins</h3>

<p>Global bindings are fine for functions that you want exposed to the world, but you often want local bindings inside a function. That’s what the
<code class="language-plaintext highlighter-rouge">let</code> special form is for:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn sum-of-squares
  "Given two values, return the sum of their squares."
  [a b]
  (let [a-squared (* a a)
        b-squared (* b b)]
    (+ a-squared b-squared)))
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">let</code> is followed by a vector of bindings – pairs of symbol and expression – and then one or more expressions. It creates a local binding
for each pair by evaluating the expression and binding it to the name (symbol), and then it evaluates the expressions in its body and returns
the last expression’s value (in the same way function bodies are evaluated).</p>

<p>There are several variants of <code class="language-plaintext highlighter-rouge">let</code> that are useful. The most common is probably <code class="language-plaintext highlighter-rouge">if-let</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(if-let [name (:name rc)]
  (str "Hello " name "!")
  "Who?")
</code></pre></div></div>

<p>Unlike <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">if-let</code> only allows one binding pair followed by two expressions. If the binding is “truthy”, the first expression will be evaluated,
else the second expression will be evaluated. Note that the bound symbol is only available in the <em>first</em> expression!</p>

<h3 id="loop-and-recur"><code class="language-plaintext highlighter-rouge">loop</code> and <code class="language-plaintext highlighter-rouge">recur</code></h3>

<p>Since I often tell people that functional programming means no mutable variables and therefore no loops, it might surprise you to learn that
Clojure has a <code class="language-plaintext highlighter-rouge">loop</code> construct. It isn’t quite what it seems!</p>

<p>First, let’s look at a recursive function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn fact [n] (if (zero? n) 1 (* n (fact (dec n)))))
;; (fact 1) =&gt; 1
;; (fact 3) =&gt; 6
;; (fact 5) =&gt; 120
</code></pre></div></div>

<p>Because it is recursive, it creates a new stack frame for every call to itself. You can still call it with some big numbers but eventually you will get
a stack overflow:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(fact 1000N) =&gt; 402387260077093773543702433923003985719374...
(fact 10000N) =&gt; StackOverflowError   java.math.BigInteger.valueOf (BigInteger.java:1098)
</code></pre></div></div>

<p>There’s a technique called tail recursion that allows some languages to evaluate recursive functions without needing stack frames. You
have to rewrite the function to ensure the recursive call is in the tail position (the <code class="language-plaintext highlighter-rouge">fact</code> call above is nested inside multiplcation).
Often, you need to create a helper function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn fact-helper [n prod] (if (zero? n) prod (fact-helper (dec n) (* n prod))))
(defn fact [n] (fact-helper n 1))
</code></pre></div></div>

<p>This produces the same results as <code class="language-plaintext highlighter-rouge">fact</code> above, but now the recursive call to <code class="language-plaintext highlighter-rouge">fact-helper</code> is in the tail position. Clojure doesn’t optimize this
directly but provides <code class="language-plaintext highlighter-rouge">recur</code> for you to tell the compiler you want it optimized – and to verify you really are using tail recursion:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn fact [n] (if (zero? n) 1 (* n (recur (dec n)))))
;; CompilerException: Can only recur from tail position
</code></pre></div></div>

<p>But:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn fact-helper [n prod] (if (zero? n) prod (recur (dec n) (* n prod))))
(defn fact [n] (fact-helper n 1))
(fact 10000N) =&gt; 28462596809170545189064132121198688901480514...
</code></pre></div></div>

<p>You can see that <code class="language-plaintext highlighter-rouge">recur</code> replaces the recursive call, but what it’s really doing behind the scenes is rebinding the function arguments
and “jumping” back to the beginning of the function, to avoid a function call altogether. Since this is really a loop-with-rebinding,
Clojure provides a <code class="language-plaintext highlighter-rouge">loop</code> construct that lets you do this directly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn fact [n] (loop [n n, prod 1] (if (zero? n) prod (recur (dec n) (* n prod)))))
</code></pre></div></div>

<p>This single function is identical in behavior to the <code class="language-plaintext highlighter-rouge">fact</code> / <code class="language-plaintext highlighter-rouge">fact-helper</code> pair shown immediately above. You can see how the <code class="language-plaintext highlighter-rouge">loop</code>
binding behaves just like the initial call to <code class="language-plaintext highlighter-rouge">fact-helper</code>, binding <code class="language-plaintext highlighter-rouge">fact</code>s argument <code class="language-plaintext highlighter-rouge">n</code> to the local symbol <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">1</code> to the local
symbol <code class="language-plaintext highlighter-rouge">prod</code>.</p>

<h3 id="useful-core-functions">Useful core Functions</h3>

<p>Since Clojure is all about data structures, there is a rich selection of functions that operate on them. Some of the valuable ones to know are:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(first [1 2 3 4])</code> returns the first element of a sequence: <code class="language-plaintext highlighter-rouge">1</code></li>
  <li><code class="language-plaintext highlighter-rouge">(rest [1 2 3 4])</code> returns the rest of a sequence: <code class="language-plaintext highlighter-rouge">(2 3 4)</code></li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">rest</code> of a single element sequence is an empty sequence – <code class="language-plaintext highlighter-rouge">()</code> – and the <code class="language-plaintext highlighter-rouge">rest</code> of an empty sequence is <em>also</em> an empty sequence, as is <code class="language-plaintext highlighter-rouge">rest</code> of <code class="language-plaintext highlighter-rouge">nil</code>!</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(seq some-collection)</code> returns a sequence of <code class="language-plaintext highlighter-rouge">some-collection</code>s elements if it is non-empty, else returns <code class="language-plaintext highlighter-rouge">nil</code></li>
</ul>

<p>It is common to test for empty sequences with <code class="language-plaintext highlighter-rouge">if (seq some-collection)</code>.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(cons 1 [2 3 4])</code> returns a new sequence with that element added: <code class="language-plaintext highlighter-rouge">(1 2 3 4)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(assoc {:a 1} :b 2)</code> returns a new hash map with the key associated to the value: <code class="language-plaintext highlighter-rouge">{:a 1, :b 2}</code></li>
  <li><code class="language-plaintext highlighter-rouge">(dissoc {:a 1, :b 2} :a)</code> returns a new hash map with the key removed (dissociated): <code class="language-plaintext highlighter-rouge">{:b 2}</code></li>
  <li><code class="language-plaintext highlighter-rouge">(map inc [1 2 3 4])</code> returns a new sequence with the function applied to each element: <code class="language-plaintext highlighter-rouge">(2 3 4 5]</code></li>
  <li><code class="language-plaintext highlighter-rouge">(filter even? [1 2 3 4])</code> returns a new sequence containing just the elements for which the predicate is “truthy”: <code class="language-plaintext highlighter-rouge">(2 4)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(reduce + 0 [1 2 3 4])</code> returns the value computed by repeatedly applying the function to the initial value and each element of the sequence: <code class="language-plaintext highlighter-rouge">10</code></li>
</ul>

<p>If the initial value is omitted, the first element of the sequence is used so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(reduce func some-collection)
;; is the same as
(reduce func (first some-collection) (rest some-collection))
</code></pre></div></div>

<h2 id="the-projectclj-file">The project.clj File</h2>

<p>The piece of <code class="language-plaintext highlighter-rouge">project.clj</code> you’ll touch most often is the <code class="language-plaintext highlighter-rouge">:dependencies</code> entry. This is a list of all the libraries your
program needs and the versions of each you want to use:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>:dependencies [[clj-time "0.9.0"]
               [org.clojure/clojure "1.8.0"]]
</code></pre></div></div>

<p>Libraries come from two locations by default: <a href="http://search.maven.org">Maven Central</a> and <a href="https://clojars.org">Clojars</a>.</p>

<p>Most Clojure libraries tell you what to put in <code class="language-plaintext highlighter-rouge">project.clj</code> to pull them in so you mostly won’t need to care which location
they actually come from but it’s instructive to at least know how to read this stuff and how to search for libraries yourself.</p>

<p>Each entry is called a “coordinate” and contains a “group ID” and an “artifact ID”. A single name just means that the group ID
and artifact ID are the same thing (so <code class="language-plaintext highlighter-rouge">clj-time</code> is shorthand for <code class="language-plaintext highlighter-rouge">clj-time/clj-time</code>).</p>

<p>To search Maven Central for <code class="language-plaintext highlighter-rouge">org.clojure/clojure</code> you would use the query <code class="language-plaintext highlighter-rouge">g:"org.clojure" AND a:"clojure"</code> which asks for
group ID <code class="language-plaintext highlighter-rouge">org.clojure</code> and artifact ID <code class="language-plaintext highlighter-rouge">clojure</code>. Right now there are over 90 versions of that library on Maven Central and the
latest is <code class="language-plaintext highlighter-rouge">1.9.0-alpha3</code> but if you click the <code class="language-plaintext highlighter-rouge">All (92)</code> link, you’ll see the most recent non-prerelease version is <code class="language-plaintext highlighter-rouge">1.8.0</code>
which is what <strong>Leiningen</strong> puts in <code class="language-plaintext highlighter-rouge">project.clj</code> by default (in Leiningen 2.6.1 and later).</p>

<p>On the other hand, <code class="language-plaintext highlighter-rouge">clj-time</code> comes from Clojars because it is a community project. If you search for <code class="language-plaintext highlighter-rouge">clj-time</code> you’ll
get a lot of results but most of them are not canonical versions. The most recent canonical version is https://clojars.org/clj-time but
there are other, earlier canonical versions, such as https://clojars.org/backtype/clj-time so you need to be a bit careful. If in doubt,
get on IRC, Slack, or the mailing list and ask!</p>

<p>For an overview of all the possible settings in <code class="language-plaintext highlighter-rouge">project.clj</code>, take a look at the <a href="https://github.com/technomancy/leiningen/blob/master/sample.project.clj">Sample project.clj File on GitHub</a>.</p>

<h2 id="the-buildboot-file">The build.boot File</h2>

<p>As with <strong>Leiningen</strong>’s <code class="language-plaintext highlighter-rouge">project.clj</code> file, the piece you’ll touch most often in <strong>Boot</strong>’s <code class="language-plaintext highlighter-rouge">build.boot</code> file will be the
<code class="language-plaintext highlighter-rouge">:dependencies</code> entry (in a <code class="language-plaintext highlighter-rouge">(set-env! ..)</code> call). The only additional wrinkle with <strong>Boot</strong> is that you’ll need a <code class="language-plaintext highlighter-rouge">boot.properties</code>
file as well if the version of Clojure you want to use in your project is not the same as the default version that your installation
of <strong>Boot</strong> already uses. For example, at World Singles we’re using Clojure 1.8.0 RC 4 so our <code class="language-plaintext highlighter-rouge">boot.properties</code> file contains:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOT_CLOJURE_VERSION=1.8.0-RC4
</code></pre></div></div>

<p>and then in our <code class="language-plaintext highlighter-rouge">build.boot</code> file we specify <code class="language-plaintext highlighter-rouge">[org.clojure/clojure "1.8.0-RC4"]</code> as a dependency. This is because <strong>Boot</strong> uses the
same JVM for itself as for your project’s code (whereas <strong>Leiningen</strong> uses two separate JVMs).</p>

<p><strong>Boot</strong>’s build file is “just Clojure” so you can do pretty much anything you want there. <strong>Boot</strong> provides a number of
important functions for setting up and managing projects but the main one you’ll use is <code class="language-plaintext highlighter-rouge">set-env!</code> to specify the libraries you
need (<code class="language-plaintext highlighter-rouge">:dependencies</code>), where your resources – source files etc – are (<code class="language-plaintext highlighter-rouge">:resource-paths</code>), and where your tests are (<code class="language-plaintext highlighter-rouge">:source-paths</code>).
For more detail, consult the <a href="http://boot-clj.com"><strong>Boot</strong> web site</a>.</p>

<h1 id="about-functional-programming">About Functional Programming</h1>

<p>Functional programming isn’t new. It’s origins lie in Lisp which was created in the 1950’s and is the second-oldest computer language
(second only to FORTRAN). Throughout the 70’s and 80’s a lot of functional languages were created, mostly in academia, to study the
benefits of the functional style, as well look at levels of expressiveness in programming languages. Classic functional languages
include Standard ML, Miranda, and Haskell. Haskell was a result of the proliferation of similar functional languages being created
by each university in England (and elsewhere). It was decided that a single, committee-designed functional language should exist
that included the best ideas of all of the diverse variants out there. Haskell is probably the most widely used language today from
that era. It has an extremely powerful type system and a very strong view of purity – lack of side effects – but it has been
used extensively over the last 25 years in industry as well as academia.</p>

<p>The recent resurgence of functional programming has shown itself in languages like F# from Microsoft, Scala, and Clojure, even Rust, as well
as some compile-to-JS languages like Elm and PureScript. The reason behind this resurgence is that immutable data structures and
pure functions offer the ability to write concurrent code a lot more easily and lot more safely than the mainstream OOP approach.
And we need concurrency in order to take advantage of multi-core machines, now that we’re no longer seeing continued speed increases
in individual cores like we had for the previous several decades.</p>

<p>While it may seem obvious that functional programming leans heavily on functions as building blocks, the real core values of
functional programming are avoiding mutable data and avoiding side effects in functions. The more that you can push side effects
to the edges of your program, the more of your code becomes pure functions that can be easily reasoned about, easily tested, and
often easily reused. Functional programming focuses on small, pure functions that can be composed to create larger pieces of
functionality. If you have a function <code class="language-plaintext highlighter-rouge">inc</code> that adds one to its argument and a function <code class="language-plaintext highlighter-rouge">twice</code> that doubles its argument, then
<code class="language-plaintext highlighter-rouge">(comp twice inc)</code> is a function that adds one to its argument and then doubles it: functions are like Legos that you can easily
assemble to build products.</p>

<h2 id="immutable-or-persistent-data-structures">Immutable or Persistent Data Structures</h2>

<p>In the context of functional programming, you’ll hear a lot of talk of immutable data structures and persistent data structures.
In OOP languages, you typically perform operations on a data structure to modify it in place. That means you can’t safely share
it with other pieces of code, especially across multiple threads. By contrast, in a functional language, when you perform an
operation on a data structure, you get back a new data structure that shares as much structure as possible with the original
data structure – and yet leaves the original data structure unchanged.</p>

<p>While they are designed for efficiency, it is usually at scale, rather than for small examples. In Clojure, many data structures
are “chunked” internally into groups of 32 elements. A vector of 100 elements is going to be four chunks and is optimized for
adding elements to the end of the vector. A list is optimized for adding elements at the start of it. A hash map is also chunked
and optimized for adding elements in random locations. They are also optimized for different patterns of access: a list is optimized
for purely sequential access, a vector for indexed (random) access, and a hash map for keyed (random) access.</p>

<p>Clojure and Scala share a lot of heavily optimized implementation details in their persistent data structures.</p>

<p>Despite all this efficiency, you still need to think about how to use data structures, and there are going to be some algorithms
where bashing a data structure in place is just going to be faster. It won’t be as safe, just faster. Clojure is fine with the
idea of localized mutation and has versions of vectors and hash maps that are optimized for that purpose (known as transients).</p>

<p>The most important aspect of these data structures in Clojure is the set of abstractions over them, including “sequence”
and “associative”. These are uniform ways to think
about data structures as just sequences of data (accessed in order, or randomly by keys),
no matter what their actual implementation is, so that you can apply all of
Clojure’s core functions to arbitrary data structures in standardized ways. The lack of unique types for each data structure
you use means that you don’t need unique functions to operate on them all. A function that operates on a sequence can accept
any data structure that supports the sequence abstraction. A function that operates on an associative collection can accept
any data structure that supports the associative abstraction.</p>

<p>For example, a result set from a database query is simply a sequence of associative collections. It can be mapped, filtered,
reduced using standard functions and its rows transformed using any of the standard associative functions. This allows
abstraction over different data stores as well since, from Clojure’s point of view, MySQL and MongoDB look very similar.</p>

<h2 id="functions-as-building-blocks">Functions as Building Blocks</h2>

<p>I’ve already emphasized that functional programming favors small, simple, pure functions but you can do that sort of
functional decomposition in most languages. Many modern languages allow you to write anonymous functions and pass them
around as arguments, as well as return them from functions. Even with those features available, it takes a while to
shift from an imperative style with some functions being passed around to a functional style where functions are your
primary abstraction.</p>

<p>You’ll hear the term “higher order functions” a lot but all this means is a function that accepts a function as one (or
more) of its arguments or a function that returns a function as a result. You’ll see the former in CFML with the new
<code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">filter</code>, and <code class="language-plaintext highlighter-rouge">reduce</code> member functions – or perhaps you’ve seen it in JavaScript.</p>

<p>Consider these two functions (in CFML):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function saveStuff( data ) {
    if ( validStuff( data ) ) {
        dbSave( "stuffTable", data );
    } else {
        writeLog( "Invalid stuff, not saved" );
    }
}

function saveThing( data ) {
    if ( thingIsValid( "all", data ) ) {
        dbSave( "thingTable", data );
    } else {
        writeLog( "Invalid thing, not saved" );
    }
}
</code></pre></div></div>

<p>Now, consider this function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function saveValidData( validator, type, data ) {
    if ( validator( data ) ) {
        dbSave( type &amp; "Table", data );
    } else {
        writeLog( "Invalid #type#, not saved" );
    }
}
</code></pre></div></div>

<p>This is probably not a transform you would do in CFML but it’s a natural one in a functional language, because
you would see the commonality and want to remove the duplication:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var saveStuff = function( data ) { return saveValidData( validStuff, "stuff", data ); };
var saveThing = function( data ) {
    return saveValidData(
        function( data ) { return thingIsValid( "all", data ); },
        "thing",
        data
    );
}
</code></pre></div></div>

<p>Now imagine you had a higher order function called
<code class="language-plaintext highlighter-rouge">partial</code> that accepted a function and one or more of its arguments and returned a new function that accepted
the rest of its arguments and then called it, it would be very natural to make this transform and then write:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var saveStuff = partial( saveValidData, validStuff, "stuff" );
var saveThing = partial( saveValidData, partial( thingIsValid, "all" ), "thing" );
</code></pre></div></div>

<p>This is much cleaner, especially if you had quite a few of these “save data if valid” variants.</p>

<p>Another way to write this without <code class="language-plaintext highlighter-rouge">partial</code> would be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function thingIsAllValid( data ) { return thingIsValid( "all", data ); }
function saveValidData( validator, type ) {
    // accept validator and type, return a function that accepts data
    return function( data ) {
        if ( validator( data ) ) {
            dbSave( type &amp; "Table", data );
        } else {
            writeLog( "Invalid #type#, not saved" );
        }
    }
}

var saveStuff = saveValidData( validStuff, "stuff" ); // returns a function
var saveThing = saveValidData( thingIsAllValid, "thing" );
</code></pre></div></div>

<p>You could also write “thing” validation like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function thingValidator( scope ) {
    return function( data ) {
        return thingIsValid( scope, data );
    }
}

var saveThing = saveValidData( thingValidator( "all" ), "thing" );
</code></pre></div></div>

<p>By making our functions more flexible in how they accept arguments, we make it easier to reuse them. This is functional thinking!</p>

<p>In Clojure we can define a function with multiple argument lists so this becomes even easier:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn thing-is-valid
  ([scope] (fn [data] (thing-is-valid scope data)))
  ([scope data] ... return true or false ...))

(defn save-valid-data
  ([validator type] (fn [data] (save-valid-data validator type data)))
  ([validator type data]
   (if (validator data)
     (db-save (str type "Table") data)
     (write-log (str "Invalid " type ", not saved")))))

(def save-stuff (save-valid-data valid-stuff "stuff"))
(def save-thing (save-valid-data (thing-is-valid "all") "thing")
</code></pre></div></div>

<p>No need for <code class="language-plaintext highlighter-rouge">partial</code> (although Clojure has that built-in), no need for helper functions.</p>

<h2 id="all-you-know-about-oo-programming-is-wrong">All You Know About OO Programming is Wrong</h2>

<p>I learned old-fashioned imperative procedural programming first. I learned BASIC, assembly language, Pascal and later
COBOL and FORTRAN. Although OOP has its roots back in the 50’s and 60’s (ironically, with Lisp, just like FP has its
roots in Lisp), it didn’t really go mainstream until the mid-to-late 80’s with the arrival of Eiffel and C++. I
learned a lot of FP during the 80’s but since it wasn’t going mainstream and OOP was, I switched horses to stay
employable. By the time Java appeared, OOP had become the default “standard” way to build software, even though
C++ and Java were not at all what Alan Kay had in mind when he coined the phrase “object-oriented”.</p>

<p>What most developers know as modern OOP focuses on polymorphism, inheritance, encapsulation and objects that have both
state and behavior bundled together. You construct an object with its initial state. You run a bunch of methods on it,
interacting with other objects, to modify its state, and then you query the object to get that state back out.</p>

<p>A common idiom in the OOP world for collections is an iterator. In CFML this shows up in query objects. As you loop
over the iterator, it changes its state to refer to successive elements of the underlying collection. A CFML query
refers to successive rows of the result set as you loop over it and the <code class="language-plaintext highlighter-rouge">currentrow</code> element is updated at each
iteration. Instead of a result set looking like a sequence of rows, we’re used to looking at a snapshot of the “current
row” – and that’s what iterators do to us for collections as well.</p>

<p>In addition, instead of processing collections holistically to produce either new collections or specific results,
we’re using to iterating through the elements and either modifying them in place or performing side effecting operations
along the way.</p>

<p>What makes this problematic is that you can’t then easily run this code concurrently to take advantage of multiple cores:
code that mutates collections in place or generates side effects is rarely thread safe.</p>

<p>In other words, mutable state is bad.</p>

<p>What about OOP’s other basic tenets?</p>

<p>Why do you encapsulate data? The primary reason is so that you can control mutation of that data. If your data is
immutable, encapsulation is no longer needed for that. The other argument for encapsulation is so that you can
change the representation of the state without affecting your clients. In a functional world, if you change your
representation, you can always provide a function that transforms it to the original structure and then simply
compose that transformation with any client function that needs to access it. That composed client + transform
can be refactored away over time as the client transitions to the new API. In other words, your data is your API
and there’s no need to encapsulate it (at least, not for the traditional OOP reasons).</p>

<p>Inheritance? Inheritance exists in OOP because the notion of data types is inherently tied to classes and objects.
Inheritance represents a strong coupling between an implementation and an interface or between one implementation
and another related implementation. It exists because there’s no way to separate out the notion of data types and
their relationships from the class implementation relationships. Needless to say, in a functional world, you can
choose to have relationships between data types as you need them, without being forced to create relationships
between data representations. In Clojure, in particular, you can create hierarchies of types independent of
any data and use those to guide function call dispatching.</p>

<p>Which brings us nicely to polymorphism! Polymorphism is great. It’s very useful. Unfortunately, in OOP it is
tied to inheritance which, as we’ve just seen, is all about coupling when you’re dealing with classes. If you
only ever use interfaces and pure implementations, you can free yourself from some of the problems of coupling
forced on you by OOP, but you still get stuck if you have a class (implementation) that isn’t declared to
implement an interface that you need to use, even though it has the right methods. Nor can you easily take
an arbitrary existing class and make it implement your interface (you can extend the class and implement your
interface, only if the class is not final in Java, for example). In addition to all that, polymorphism in OOP
is only effective on the first argument – the object type itself – which means that when faced with more
complex problems, you have to resort to design patterns like Visitor and implement double dispatch. But then
you are forced to modify the “visited” class every time you want to visit it with a new class. What you really
need there is polymorphism based on multiple arguments. Fortunately, you can have that in functional programming.</p>

<p>So what have we learned?</p>

<p>Polymorphism is very limited in OOP but can be very powerful in FP once we remove the restriction of single
dispatch and the coupling to a static inheritance hierarchy: this gives you ad hoc or a la carte polymorphism.</p>

<p>Inheritance as seen in OOP is essentially an implementation detail. You can have ad hoc inheritance in FP,
which provides expressiveness where you want it and avoids boilerplate and coupling where you don’t.</p>

<p>Encapsulation is required in OOP when you have mutatable state and is also needed in order to allow changes in
implementation. In other words, encapsulation is also essentially an implementation detail. FP solves this
by making data immutable and making functions easily composable.</p>

<p>Mutable state is just bad. It prevents refactoring to leverage concurrency, it leads to hard to find bugs
in complex programs, and it also erases any notion of time in your program (because you have only the
current version of the state, rather than the series of values that were transformed to get to that point).
FP solves that by removing mutability.</p>

<p>If FP is so great, why aren’t we all using it already?</p>

<p>Good question. The OOP industry is vast. Design Patterns, training and consulting, higher education based on
teaching OOP (ironically after supplanting a lot of courses that taught FP!), testing, tooling, IDEs. The
momentum behind OOP is huge and the inertia of industry to keep doing things the way they know is almost
overwhelming. Yet we see functional features in nearly every new language being designed, we see functional
features being added to nearly every existing language over time, we see the functional style of programming
being advocated even in traditional languages – with less reliance on mutable state. Most of that pressure
is coming from the need to do more concurrency and to avoid the bugs that arise from side-effecting code.
In other words, a lot of people already know that FP is a better way to solve a lot of problems.</p>

<p>Remember that modern OOP – as enshrined in Java and C# particularly – is not what the originators of OOP had
in mind. They imagined objects as proxies for real world elements such as displays and control devices, that
objects would be coarse-grained and communicate by sending messages between themselves. <em>In other words, they
would be more like “actors”… which you have in both Clojure (as agents) and Scala (as actors)!</em></p>

<h1 id="more-stuff-to-read">More Stuff to Read</h1>

<p>Once you’ve got a taste for Clojure, there are lots of online resources and a host of great books you can read.
Here’s a small sample, roughly in order of approachability:</p>

<ul>
  <li>The online tutorial for learning Clojure, no installation required: http://www.tryclj.com</li>
  <li>The “4Clojure” puzzles online: https://www.4clojure.com
    <ul>
      <li>These quickly get hard enough that you’ll want a REPL open locally to play with!</li>
    </ul>
  </li>
  <li>The Clojure Koans: http://clojurekoans.com
    <ul>
      <li>You need at least Java, Leiningen, and Git installed for these.</li>
    </ul>
  </li>
  <li>Some great books to read:
    <ul>
      <li>Clojure for the Brave and True http://www.braveclojure.com (introductory level)</li>
      <li>Living Clojure http://shop.oreilly.com/product/0636920034292.do (introduces Clojure, but assumes you’re an experienced developer in other languages)</li>
      <li>Clojure Programming http://www.clojurebook.com (deep technical coverage)</li>
      <li>The Joy Of Clojure http://www.joyofclojure.com (focused on the “why” of Clojure)</li>
    </ul>
  </li>
</ul>

<h1 id="digging-into-reloading">Digging Into Reloading</h1>

<p><em>More to come on this, eventually!</em></p>

</article>

		<footer class="site-footer">
			
				<span class="site-footer-owner"><a href="https://github.com/sneiland/sneiland.github.io">sneiland.github.io</a> is maintained by <a href="https://github.com/sneiland">sneiland</a>.</span>
			
		</footer>
	</main>
</body>
</html>