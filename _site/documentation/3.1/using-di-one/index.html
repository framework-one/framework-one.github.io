<!DOCTYPE html>
<html lang="en-US">
<head>
	
	<meta charset="UTF-8">

	<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Using DI/1 | FW/1 - The Invisible Framework</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Using DI/1" />
<meta name="author" content="Sean Corfield" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Framework One - is a family of small, lightweight, convention-over-configuration frameworks, primarily for CFML. FW/1 itself provides MVC, DI/1 provides dependency injection (a.k.a. inversion of control), and AOP/1 provides aspect-oriented programming features on top of DI/1." />
<meta property="og:description" content="Framework One - is a family of small, lightweight, convention-over-configuration frameworks, primarily for CFML. FW/1 itself provides MVC, DI/1 provides dependency injection (a.k.a. inversion of control), and AOP/1 provides aspect-oriented programming features on top of DI/1." />
<link rel="canonical" href="http://localhost:4000/documentation/3.1/using-di-one/" />
<meta property="og:url" content="http://localhost:4000/documentation/3.1/using-di-one/" />
<meta property="og:site_name" content="FW/1 - The Invisible Framework" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-07-01T18:20:00-04:00" />
<script type="application/ld+json">
{"headline":"Using DI/1","dateModified":"2017-07-01T18:20:00-04:00","datePublished":"2017-07-01T18:20:00-04:00","url":"http://localhost:4000/documentation/3.1/using-di-one/","author":{"@type":"Person","name":"Sean Corfield"},"description":"Framework One - is a family of small, lightweight, convention-over-configuration frameworks, primarily for CFML. FW/1 itself provides MVC, DI/1 provides dependency injection (a.k.a. inversion of control), and AOP/1 provides aspect-oriented programming features on top of DI/1.","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/documentation/3.1/using-di-one/"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<meta name="theme-color" content="#157878" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
	<link rel="stylesheet" href="/assets/css/style.css?v=a3debbe0e02ab81ebdefec1b0e258acd9a63d866" />
	<link href="/atom.xml" rel="alternate" title="FW/1 - The Invisible Framework" type="application/atom+xml">
</head>
<body>
	<a id="skip-to-content" href="#content">Skip to the content.</a>

	<header class="page-header" role="banner">
		<h1 class="project-name">Using DI/1</h1>
		<h2 class="project-tagline">Framework One - is a family of small, lightweight, convention-over-configuration frameworks, primarily for CFML. FW/1 itself provides MVC, DI/1 provides dependency injection (a.k.a. inversion of control), and AOP/1 provides aspect-oriented programming features on top of DI/1.</h2>
		
		<a href="/" class="btn">Home</a>
		<a href="/blog" class="btn">Blog</a>
		<a href="/documentation" class="btn">Documentation</a>
		
			<a href="https://github.com/framework-one/fw1/" class="btn" target="_blank">View on GitHub</a>
		
		
			<a href="https://github.com/framework-one/fw1/archive/master.zip" class="btn">Download 4.2 (Current)</a>
			<a href="https://github.com/framework-one/fw1/archive/v4.3.0-beta.1.zip" class="btn">Download 4.3 (Beta)</a>
		
		
			<a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS" class="btn">RSS</a>
		
	</header>

	<main id="content" class="main-content" role="main">
		<aside class="documentation-nav">
	<section>
		<a href="/documentation/changelog">Changelog</a><br />
		<a href="/documentation/roadmap/">Roadmap</a><br />
	</section>
	<section>
		<h3>4.3 Documentation (beta)</h3>
		<a href="/documentation/4.3/">Getting Started Guide</a><br />
		<a href="/documentation/4.3/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/4.3/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/4.3/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/4.3/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/4.3/reference-manual/">Reference Manual</a><br />
		<a href="/documentation/4.3/changelog/">Change Log</a><br />
	</section>
	<section>
		<h3>4.2 Documentation (Current Master)</h3>
		<a href="/documentation/4.2/">Getting Started Guide</a><br />
		<a href="/documentation/4.2/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/4.2/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/4.2/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/4.2/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/4.2/reference-manual/">Reference Manual</a><br />
		<a href="/documentation/4.2/changelog/">Change Log</a><br />
	</section>
	<section>
		<h3>4.1 Documentation</h3>
		<a href="/documentation/4.1/">Getting Started Guide</a><br />
		<a href="/documentation/4.1/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/4.1/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/4.1/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/4.1/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/4.1/reference-manual/">Reference Manual</a><br />
		<a href="/documentation/4.1/changelog/">Change Log</a><br />
	</section>
	<section>
		<h3>4.0 Documentation</h3>
		<a href="/documentation/4.0/">Getting Started Guide</a><br />
		<a href="/documentation/4.0/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/4.0/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/4.0/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/4.0/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/4.0/reference-manual/">Reference Manual</a><br />
		<a href="/documentation/4.0/changelog/">Change Log</a><br />
	</section>
	<section>
		<h3>3.5 Documentation</h3>
		<a href="/documentation/3.5/">Getting Started Guide</a><br />
		<a href="/documentation/3.5/cfml-and-clojure/">CFML and Clojure</a><br />
		<a href="/documentation/3.5/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/3.5/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/3.5/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/3.5/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/3.5/reference-manual/">Reference Manual</a><br />
	</section>
	<section>
		<h3>3.1 Documentation</h3>
		<a href="/documentation/3.1/">Getting Started Guide</a><br />
		<a href="/documentation/3.1/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/3.1/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/3.1/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/3.1/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/3.1/reference-manual/">Reference Manual</a><br />
	</section>
	<section>
		<h3>3.0 Documentation</h3>
		<a href="/documentation/3.0/">Getting Started Guide</a><br />
		<a href="/documentation/3.0/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/3.0/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/3.0/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/3.0/reference-manual/">Reference Manual</a><br />
	</section>
</aside>

<article>
	<p>DI/1 - a.k.a Inject One - is a simple, convention-based Dependency Injection framework.</p>

<p>DI/1 searches specified directories for CFCs and treats them as singletons or non-singletons (transients) based on naming conventions for the CFCs themselves, or the folders in which they are found. You can override the conventions by configuration if needed.</p>

<h3 id="terminology">Terminology</h3>
<ul>
  <li><strong>Bean</strong>: A CFC that you want to create and manage. Any file with a .cfc extension can be a bean.</li>
  <li><strong>Transient</strong> or <strong>non-singleton</strong> : A bean that will be freshly created each time you call <code class="language-plaintext highlighter-rouge">getBean()</code>. It could be used for only the lifespan of the request, e.g., a shopping cart object ready to be populated with items.</li>
  <li><strong>Singleton</strong>: A bean where only one exists in the system, so that each time you call <code class="language-plaintext highlighter-rouge">getBean()</code> you will get the <strong>same</strong> bean, not a new one, e.g., a service that creates shopping cart objects.</li>
  <li><strong>Bean Factory</strong>: A service that creates beans for you, so you don’t have to use <code class="language-plaintext highlighter-rouge">new</code> or <code class="language-plaintext highlighter-rouge">createObject</code>, and populates them with any dependencies.</li>
</ul>

<h1 id="getting-started-with-di1">Getting Started with DI/1</h1>

<p>Create an instance of the DI/1 bean factory and specify the folder(s) you want it to search for beans (CFCs):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var beanFactory = new ioc("/model");
// or multiple folders:
var beanFactory = new ioc("/model,/common/model");
// or an array:
var beanFactory = new ioc(["/model","/common/model"]);
</code></pre></div></div>

<p>CFCs found in a folder called <code class="language-plaintext highlighter-rouge">beans</code> are assumed to be transients; otherwise CFCs are assumed to be singletons, this includes beans found in folders under the <code class="language-plaintext highlighter-rouge">beans</code> folder. If CFC names are unique, you can use that name to get the bean out of the factory:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var userManager = beanFactory.getBean("userManager");
</code></pre></div></div>

<p>All beans are also given an alias which is the name of the CFC followed by (the singular form of) the folder name in which it was found, e.g., /model/beans/product.cfc would get the alias “productBean”. If no other CFC is called product.cfc in the folders that you asked DI/1 to search, you can use “product” or “productBean” to reference that bean. By default, DI/1 assumes all beans are singletons unless they are found in a folder called <code class="language-plaintext highlighter-rouge">beans</code> (in which case DI/1 assumes those are transients). A singleton has just a single instance and DI/1 will cache that instance. A transient is created afresh every time you ask DI/1 for an instance.</p>

<p>If a CFC has a constructor (a method called <code class="language-plaintext highlighter-rouge">init()</code>), DI/1 will use the argument names to look up beans and call the constructor with those beans. If a CFC has setter methods, DI/1 will use their names to look up beans and call the setters with those beans. If a CFC has property declarations and implicit setters are enabled, DI/1 will use their names to look up beans and call the implicit setters with those beans. This is called autowiring. By the time you get a bean back from DI/1, it should be fully populated. You can also specify an “init-method” function name that DI/1 should call after a bean has had its dependencies injected - see <strong><a href="#configuration">Configuration</a></strong> below.</p>

<p>If DI/1 cannot find a matching bean for a constructor argument, it will throw an exception. If DI/1 cannot find a matching bean for a setter method or property, it will log the failure and ignore it (by default), and the corresponding variable will not be populated. You can configure DI/1 to be strict about matching bean names - see the configuration section below - in which case it will throw an exception.</p>

<p>Note that DI/1 will inject both singletons and transients via constructors, but it will inject only singletons via setters or properties, not transients. Injecting transients in those situations often leads to unexpected results (consider a transient <code class="language-plaintext highlighter-rouge">invoice</code> bean that has a <code class="language-plaintext highlighter-rouge">setCustomer()</code> method when you also have a transient <code class="language-plaintext highlighter-rouge">customer</code> bean - you almost certainly don’t want DI/1 to automatically create a customer instance and inject it every time you ask DI/1 for a new invoice bean!). If a constructor argument matches a transient bean, DI/1 will still create an instance since it has to finish constructing the original bean.</p>

<h2 id="acceptable-folder-paths">Acceptable Folder Paths</h2>

<p>In general, you should use webroot-relative folders - starting with <code class="language-plaintext highlighter-rouge">/</code> - or mappings - also starting with <code class="language-plaintext highlighter-rouge">/</code> - as the constructor arguments to <code class="language-plaintext highlighter-rouge">ioc</code>. If you pass a full file system path, DI/1 will only be able to deduce the dotted-name of CFCs found there if it points into the webroot tree. Similarly, if you pass a relative folder path, it must point into the webroot tree. If DI/1 cannot deduce the dotted name of a CFC, it will throw an exception.</p>

<h1 id="more-advanced-usage">More Advanced Usage</h1>

<p>This section covers the rest of the public API, how to specify additional folders as containing transients, parent bean factories and bean factory injection.</p>

<h2 id="other-public-methods">Other Public Methods</h2>

<p>Given a struct of values (such as form scope or URL scope), you can ask DI/1 to inject those values as properties into a given bean:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bean = beanFactory.injectProperties(myBeanInstance, form);
user = beanFactory.injectProperties("user", userAttributes);
</code></pre></div></div>

<p>The first call will loop over the form scope and, for each key in that scope, call a setter on <code class="language-plaintext highlighter-rouge">myBeanInstance</code>. The second call asks DI/1 to create a <code class="language-plaintext highlighter-rouge">user</code> bean and populate it by calling a setter for each element of the struct <code class="language-plaintext highlighter-rouge">userAttributes</code>. You may also use a dotted-path to a CFC as the first argument in which case DI/1 will use <code class="language-plaintext highlighter-rouge">createObject</code> to instantiate it and <em>will not call the constructor</em>. Caution: DI/1 assumes you know what you’re doing and will call a setter for <em>every</em> member of the struct passed in!</p>

<p>You can programmatically add new bean instances - or named values:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>beanFactory.addBean("magicvalue", 42);
beanFactory.addBean("logger", new LogFactory("log4j"));
</code></pre></div></div>

<p>After these calls, <code class="language-plaintext highlighter-rouge">getBean("magicvalue")</code> will return the value 42 and <code class="language-plaintext highlighter-rouge">getBean("logger")</code> will return the CFC instance you provided. That means that any properties, setter methods or constructor arguments that refer to <code class="language-plaintext highlighter-rouge">magicvalue</code> or <code class="language-plaintext highlighter-rouge">logger</code> will get those values injected.</p>

<p>You can also programmatically declare new beans to be managed by DI/1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>beanFactory.declareBean("navigation", "site.utils.navigation", true);
</code></pre></div></div>

<p>That will tell DI/1 that <code class="language-plaintext highlighter-rouge">/site/utils/navigation.cfc</code> should be managed as a singleton with name <code class="language-plaintext highlighter-rouge">navigation</code>. You can declare transients by specifying <code class="language-plaintext highlighter-rouge">false</code> as the third argument. <code class="language-plaintext highlighter-rouge">true</code> is the default so it can be omitted for singletons.</p>

<p>When declaring a bean, you can also optionally provide a set of overrides for named beans, so that constructor arguments or properties will take on specified values, rather than what is managed by the bean factory. This is useful for creating variants of a single bean:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>beanFactory.declareBean("datasource", "util.DataSource", true, { dsn = "main" } );
beanFactory.declareBean("admindata", "util.DataSource", true, { dsn = "admindb" } );
</code></pre></div></div>

<p>You can declare a factory bean - like Spring/ColdSpring - as follow:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>beanFactory.factoryBean("generated", factory, "method", [ ..args.. ], { ... } );
</code></pre></div></div>

<p>This tells DI/1 that when you call <code class="language-plaintext highlighter-rouge">getBean("generated")</code>, instead of trying to create the bean itself, it should call <code class="language-plaintext highlighter-rouge">factory.method(..args..)</code> to get the bean instance. <code class="language-plaintext highlighter-rouge">args</code> can be omitted (and defaults to an empty list of arguments). The last argument provides overrides for bean values, as shown above, and is optional.</p>

<p>You can add an alias for a bean:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>beanFactory.addAlias("alsoKnownAs", "navigation");
</code></pre></div></div>

<p>That will tell DI/1 that <code class="language-plaintext highlighter-rouge">alsoKnownAs</code> is an alias for the bean identified by <code class="language-plaintext highlighter-rouge">navigation</code> so <code class="language-plaintext highlighter-rouge">getBean("alsoKnownAs")</code> will behave the same as <code class="language-plaintext highlighter-rouge">getBean("navigation")</code>.</p>

<p>If you want code to be executed after DI/1 has discovered all the beans on disk – for example, to configure a variety of additional “constant” or computed beans – you can use the <code class="language-plaintext highlighter-rouge">onLoad()</code> method to specify a listener function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>beanFactory.onLoad( loadListener );
</code></pre></div></div>

<p>That will register <code class="language-plaintext highlighter-rouge">loadListener</code> with DI/1 to be called after bean discovery is complete. This is a good place to put your calls to <code class="language-plaintext highlighter-rouge">declareBean()</code> and <code class="language-plaintext highlighter-rouge">addAlias()</code> if you need those to be in effect prior to the first call to <code class="language-plaintext highlighter-rouge">getBean()</code>.</p>

<ul>
  <li>If <code class="language-plaintext highlighter-rouge">loadListener</code> is a CFC instance, DI/1 will call <code class="language-plaintext highlighter-rouge">loadListener.onLoad( beanFactory )</code>, passing the DI/1 instance in as an argument.</li>
  <li>If <code class="language-plaintext highlighter-rouge">loadListener</code> is a bean name, DI/1 will call <code class="language-plaintext highlighter-rouge">beanFactory.getBean( loadListener ).onLoad( beanFactory )</code>, where <code class="language-plaintext highlighter-rouge">beanFactory</code> is the DI/1 instance.</li>
  <li>If <code class="language-plaintext highlighter-rouge">loadListener</code> is a function or closure, DI/1 will call <code class="language-plaintext highlighter-rouge">loadListener( beanFactory )</code>. Note that if <code class="language-plaintext highlighter-rouge">loadListener</code> is a method on a CFC, it will be called out of context so it will not have access to the <code class="language-plaintext highlighter-rouge">variables</code> scope or <code class="language-plaintext highlighter-rouge">this</code> scope of that CFC instance and therefore also won’t have access to other methods of that CFC.</li>
</ul>

<p>You can ask if the bean factory knows about a particular bean using the <code class="language-plaintext highlighter-rouge">containsBean()</code> method:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ( beanFactory.containsBean("productService") ) ...
</code></pre></div></div>

<p>(although you probably shouldn’t need to do this unless you are building some sort of framework plugin that needs to check what is available to it at runtime!).</p>

<p>You can force all singletons to be reloaded using the <code class="language-plaintext highlighter-rouge">load()</code> method:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>beanFactory.load();
</code></pre></div></div>

<p>That will empty the bean cache and then call <code class="language-plaintext highlighter-rouge">getBean()</code> on every bean that DI/1 knows about. Note: it does not call <code class="language-plaintext highlighter-rouge">load()</code> on any parent bean factory (see below) and it does not perform a new search on the folders (so it won’t see newly written CFCs). To force the search to be performed again, create a new instance of the bean factory as shown above.</p>

<p>Metadata can be queried using the following methods:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ( beanFactory.isSingleton("someBean") ) ...
info = beanFactory.getBeanInfo("someBean");
</code></pre></div></div>

<p>I would expect these only to be useful to framework authors. Both methods walk up into parent bean factories, if present. If you omit the bean name for <code class="language-plaintext highlighter-rouge">getBeanInfo()</code> you get back a struct with a key <code class="language-plaintext highlighter-rouge">beanInfo</code> that refers to metadata for all of the beans known in the factory. If there is a parent bean factory, its metadata is returned under a key <code class="language-plaintext highlighter-rouge">parent</code> in that struct.</p>

<p><code class="language-plaintext highlighter-rouge">getBeanInfo()</code> can be called with a <code class="language-plaintext highlighter-rouge">beanName</code> argument - the default - or with a <code class="language-plaintext highlighter-rouge">regex</code> argument which will return metadata about all the beans in the factory whose names match the regular expression, in a struct with the single key <code class="language-plaintext highlighter-rouge">beanInfo</code>, whose value will be a struct with a key for each matching bean.</p>

<p><code class="language-plaintext highlighter-rouge">getBeanInfo()</code> can also be called with no arguments, in which case it will return metadata for all the beans in the factory (in the <code class="language-plaintext highlighter-rouge">beanInfo</code> key of the result) and metadata for all the beans in the factory’s parent, if any, in the <code class="language-plaintext highlighter-rouge">parent</code> key of the result. Optionally, you may specify an argument of <code class="language-plaintext highlighter-rouge">flatten = true</code> and the <code class="language-plaintext highlighter-rouge">parent</code> structures will be merged (recursively through the parents) into <code class="language-plaintext highlighter-rouge">beanInfo</code>, producing a flat struct.</p>

<p><code class="language-plaintext highlighter-rouge">getConfig()</code> can be called to get a copy of the bean factory’s configuration, in case you need to have conditional behavior in your load listeners.</p>

<h2 id="specifying-additional-transient-beans">Specifying Additional Transient Beans</h2>

<p>By default, any CFC in the <code class="language-plaintext highlighter-rouge">beans</code> folder is considered a transient and everything else is considered a singleton. There are three ways to specify other CFCs should be considered transient:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">config.singulars</code> allows you to specify additional folders that resolve to <code class="language-plaintext highlighter-rouge">bean</code></li>
  <li><code class="language-plaintext highlighter-rouge">config.transients</code> allows you to specify additional folders whose contents are transient</li>
  <li><code class="language-plaintext highlighter-rouge">config.singletonPattern</code> allows you to specify a regular expression which limits which beans are considered singletons</li>
  <li><code class="language-plaintext highlighter-rouge">config.transientPattern</code> allows you to specify a regular expression which limits which beans are considered transients</li>
</ul>

<p>In the first case, any folder name whose singular name is <code class="language-plaintext highlighter-rouge">bean</code> will cause CFCs to get an alias that ends in <code class="language-plaintext highlighter-rouge">Bean</code> and will be considered transients. In the second case, the singular transformation will still be applied to create the alias, but the CFCs will be considered transients anyway. See below for additional uses of <code class="language-plaintext highlighter-rouge">config.singulars</code>. In the third case, CFCs will also be considered transients if their name does not match the regular expression pattern supplied. In the fourth case, CFCs will also be considered transients if their name matches the regular expression pattern supplied. You cannot specify both <code class="language-plaintext highlighter-rouge">config.singletonPattern</code> and <code class="language-plaintext highlighter-rouge">config.transientPattern</code>.</p>

<p>For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var beanFactory = new ioc( ".", { singulars = { objects = "bean" }, transients = [ "models" ] } );
</code></pre></div></div>

<p>This will cause CFCs found in the <code class="language-plaintext highlighter-rouge">objects</code> folder to be treated as if they were in the <code class="language-plaintext highlighter-rouge">beans</code> folder (their alias will end with <code class="language-plaintext highlighter-rouge">Bean</code> and they will be considered transients because of that) and CFCs found in the <code class="language-plaintext highlighter-rouge">models</code> folder to be treated as transients too (but their alias will end with <code class="language-plaintext highlighter-rouge">Model</code>, the singular of <code class="language-plaintext highlighter-rouge">models</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var beanFactory = new ioc( ".", { singulars = { services = "manager" }, transients = [ "objects" ] } );
</code></pre></div></div>

<p>This, on the other hand, will cause CFCs found in the <code class="language-plaintext highlighter-rouge">services</code> folder to be treated as if they were in the <code class="language-plaintext highlighter-rouge">managers</code> folder (their alias will end with <code class="language-plaintext highlighter-rouge">Manager</code> and they will be considered singletons because of that) and CFCs found in the <code class="language-plaintext highlighter-rouge">objects</code> folder to be treated as transients (their alias will end with <code class="language-plaintext highlighter-rouge">Object</code>, the singular of <code class="language-plaintext highlighter-rouge">objects</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var beanFactory = new ioc( ".", { singletonPattern = "(Service|Factory)$" } );
</code></pre></div></div>

<p>In addition to any CFCs found in a folder called <code class="language-plaintext highlighter-rouge">beans</code>, any CFC whose name does not end in <code class="language-plaintext highlighter-rouge">Service</code> or <code class="language-plaintext highlighter-rouge">Factory</code> will be considered a transient.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var beanFactory = new ioc( ".", { transientPattern = "(Entity)$" } );
</code></pre></div></div>

<p>In addition to any CFCs found in a folder called <code class="language-plaintext highlighter-rouge">beans</code>, any CFC whose name ends in <code class="language-plaintext highlighter-rouge">Entity</code> will be considered a transient.</p>

<h2 id="parent-bean-factories">Parent Bean Factories</h2>

<p>If your application is assembled from multiple modules, you may have a main bean factory containing shared CFCs and each module may also have a bean factory. You can tell a module’s bean factory about the shared CFCs in the main bean factory using the <code class="language-plaintext highlighter-rouge">setParent()</code> method:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var moduleBeanFactory = new ioc("/moduleModel");
moduleBeanFactory.setParent( mainBeanFactory );
</code></pre></div></div>

<p>This causes DI/1 to ask its parent bean factory about any beans that are requested but unknown (within the moduleBeanFactory). Because DI/1 uses only <code class="language-plaintext highlighter-rouge">containsBean(name)</code> and <code class="language-plaintext highlighter-rouge">getBean(name)</code> the parent bean factory does not need to be another DI/1 instance - it can be any bean factory that provides that API.</p>

<h2 id="bean-factory-aware">Bean Factory Aware</h2>

<p>If you need access to the bean factory itself within one of your CFCs, either declare a constructor argument called <code class="language-plaintext highlighter-rouge">beanFactory</code>, provide a <code class="language-plaintext highlighter-rouge">setBeanFactory( any beanFactory )</code> setter or declare a <code class="language-plaintext highlighter-rouge">beanFactory</code> property (with implicit setters enabled). DI/1 declares itself as a bean called <code class="language-plaintext highlighter-rouge">beanFactory</code> and will inject itself where any such dependencies appear.</p>

<h1 id="configuration">Configuration</h1>

<p>When you create the bean factory, you can optionally supply a second argument that is a struct containing configuration for DI/1. At present, DI/1 understands the follow config options:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">constants</code> - struct - defaults to <code class="language-plaintext highlighter-rouge">{}</code>. DI/1 will use any name/value pairs specified here to provide <em>beans</em> that resolve to the specified values. This can be used to provide resolution for constructor arguments that need values which are not actual beans.</li>
  <li><code class="language-plaintext highlighter-rouge">exclude</code> - array - defaults to <code class="language-plaintext highlighter-rouge">[]</code>. DI/1 will ignore any CFCs whose file path contains the strings in this array. DI/1 always excludes paths containing <code class="language-plaintext highlighter-rouge">/WEB-INF</code> and <code class="language-plaintext highlighter-rouge">/Application.cfc</code>, as well as various FW/1 and DI/1 framework files. The strings are not case-sensitive.</li>
  <li><code class="language-plaintext highlighter-rouge">initMethod</code> - string - If specified, identifies a method name on beans that DI/1 will attempt to call (with no arguments) on each bean after its dependencies have been injected.</li>
  <li><code class="language-plaintext highlighter-rouge">omitDirectoryAliases</code> - boolean - defaults to <code class="language-plaintext highlighter-rouge">false</code>. If <code class="language-plaintext highlighter-rouge">true</code>, use CFC names as bean names directly, without appending the singular directory name as a suffix. If your CFC names are not unique, you will get an exception.</li>
  <li><code class="language-plaintext highlighter-rouge">omitTypedProperties</code> - boolean - defaults to <code class="language-plaintext highlighter-rouge">false</code>. If <code class="language-plaintext highlighter-rouge">true</code>, property declarations that specify a type will be ignored for injection. That is useful if you are working with the ORM (since those property declarations will have types and should not be treated as dependencies).</li>
  <li><code class="language-plaintext highlighter-rouge">recurse</code> - boolean - defaults to <code class="language-plaintext highlighter-rouge">true</code>. Controls whether DI/1 searches subfolders recursively or not.</li>
  <li><code class="language-plaintext highlighter-rouge">singletonPattern</code> - string - no default. Specifies a regular expression that DI/1 uses to determine whether a bean is singleton or not, based on its name. The <code class="language-plaintext highlighter-rouge">beans</code> folder convention and the <code class="language-plaintext highlighter-rouge">transients</code> configuration below still apply so nothing in those folders will be considered a singleton, even if its name matches the pattern.</li>
  <li><code class="language-plaintext highlighter-rouge">singulars</code> - struct - defaults to <code class="language-plaintext highlighter-rouge">{}</code>. DI/1 will use any name/value pairs specified here to translate folder names to a singular variety, e.g., <code class="language-plaintext highlighter-rouge">pride = 'lion'</code> will convert the <em>plural</em> folder <code class="language-plaintext highlighter-rouge">pride</code> to the <em>singular</em> name <code class="language-plaintext highlighter-rouge">lion</code> and therefore a <code class="language-plaintext highlighter-rouge">simba.cfc</code> within the <code class="language-plaintext highlighter-rouge">pride</code> folder will get the alias <code class="language-plaintext highlighter-rouge">simbaLion</code>. This also allows for other folders to behave as if they were called <code class="language-plaintext highlighter-rouge">beans</code> by treating their singular name as <code class="language-plaintext highlighter-rouge">bean</code>. One of the DI/1 unit tests maps <code class="language-plaintext highlighter-rouge">sheep</code> to <code class="language-plaintext highlighter-rouge">bean</code> for this reason. This won’t work if the CFCs in <code class="language-plaintext highlighter-rouge">sheep</code> have the same name as the CFCs in <code class="language-plaintext highlighter-rouge">beans</code> however.</li>
  <li><code class="language-plaintext highlighter-rouge">strict</code> - boolean - defaults to <code class="language-plaintext highlighter-rouge">false</code>. If <code class="language-plaintext highlighter-rouge">true</code>, DI/1 will throw an exception if it cannot resolve a bean implied by a constructor argument, setter name or property name. If <code class="language-plaintext highlighter-rouge">false</code>, DI/1 simply calls <code class="language-plaintext highlighter-rouge">logMissingBean()</code> which writes the failure to the Java console.</li>
  <li><code class="language-plaintext highlighter-rouge">transients</code> - array - defaults to <code class="language-plaintext highlighter-rouge">[]</code>. DI/1 will consider any CFCs found in these folders to be transient, rather than singleton. The conversion to a singular form will still take place to create the alias for each CFC. For example, if <code class="language-plaintext highlighter-rouge">singulars = { pride = 'lion' }</code> and <code class="language-plaintext highlighter-rouge">transients = [ 'pride' ]</code> then any CFCs in the <code class="language-plaintext highlighter-rouge">pride</code> folder will be treated as transients and their alias will end in <code class="language-plaintext highlighter-rouge">Lion</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">transientPattern</code> - string - no default. Specifies a regular expression that DI/1 uses to determine whether a bean is transient or not, based on its name. The <code class="language-plaintext highlighter-rouge">beans</code> folder convention and the <code class="language-plaintext highlighter-rouge">transients</code> configuration below still apply so CFCs in those folders will be still considered transients, in addition to any name that matches the pattern.</li>
</ul>

<h2 id="configuring-constant-beans">Configuring “Constant” Beans</h2>

<p>As noted above, the optional config argument to the <code class="language-plaintext highlighter-rouge">ioc</code> constructor is a struct containing various parameters that alter the behavior of DI/1. The <code class="language-plaintext highlighter-rouge">constants</code> config element is a struct containing mappings from bean names to specific constant values. This allows you to specify non-CFC values for constructor arguments, setters and properties (but is most commonly used for constructor arguments). The value may be of any type and any reference to that bean name will return the specified value as a singleton.</p>

<p>These values may be added after DI/1 has been initialized using the <code class="language-plaintext highlighter-rouge">addBean()</code> method as shown above.</p>

<h2 id="overriding-di1-behavior">Overriding DI/1 Behavior</h2>

<p>If you want to override the methods in DI/1, such as <code class="language-plaintext highlighter-rouge">logMissingBean()</code>, you can create your own CFC that extends <code class="language-plaintext highlighter-rouge">ioc.cfc</code> and overrides the desired methods. Then use your CFC instead of <code class="language-plaintext highlighter-rouge">ioc.cfc</code>. If any particular use case becomes common, we can discuss incorporating it into DI/1 as a configuration option.</p>

<p>A particular extension point that is provided is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void function setupInitMethod( string name, any bean )
</code></pre></div></div>

<p>This is called for each bean after its dependencies have been injected prior to calling <code class="language-plaintext highlighter-rouge">initMethod</code> (if specified).</p>

<p>Two related extension points that can be useful as well are:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private any function construct( string dottedPath )

private any function metadata( string dottedPath )
</code></pre></div></div>

<p>These can be overridden if you want to change the behavior of how beans are created and how metadata is obtained for beans. An example from Adam Tuttle is the ability to silently ignore beans that have syntax errors during development, so the rest of the beans are loaded: you would override <code class="language-plaintext highlighter-rouge">metadata()</code> and have it wrap a call to <code class="language-plaintext highlighter-rouge">super.metadata( dottedPath )</code> in <code class="language-plaintext highlighter-rouge">try/catch</code> and return an empty struct if an exception is thrown.</p>

</article>

		<footer class="site-footer">
			
				<span class="site-footer-owner"><a href="https://github.com/sneiland/sneiland.github.io">sneiland.github.io</a> is maintained by <a href="https://github.com/sneiland">sneiland</a>.</span>
			
		</footer>
	</main>
</body>
</html>