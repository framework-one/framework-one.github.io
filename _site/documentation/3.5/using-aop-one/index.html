<!DOCTYPE html>
<html lang="en-US">
<head>
	
	<meta charset="UTF-8">

	<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Using AOP/1 | FW/1 - The Invisible Framework</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Using AOP/1" />
<meta name="author" content="Sean Corfield" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Framework One - is a family of small, lightweight, convention-over-configuration frameworks, primarily for CFML. FW/1 itself provides MVC, DI/1 provides dependency injection (a.k.a. inversion of control), and AOP/1 provides aspect-oriented programming features on top of DI/1." />
<meta property="og:description" content="Framework One - is a family of small, lightweight, convention-over-configuration frameworks, primarily for CFML. FW/1 itself provides MVC, DI/1 provides dependency injection (a.k.a. inversion of control), and AOP/1 provides aspect-oriented programming features on top of DI/1." />
<link rel="canonical" href="http://localhost:4000/documentation/3.5/using-aop-one/" />
<meta property="og:url" content="http://localhost:4000/documentation/3.5/using-aop-one/" />
<meta property="og:site_name" content="FW/1 - The Invisible Framework" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-10-21T12:00:00-04:00" />
<script type="application/ld+json">
{"headline":"Using AOP/1","dateModified":"2015-10-21T12:00:00-04:00","datePublished":"2015-10-21T12:00:00-04:00","url":"http://localhost:4000/documentation/3.5/using-aop-one/","author":{"@type":"Person","name":"Sean Corfield"},"description":"Framework One - is a family of small, lightweight, convention-over-configuration frameworks, primarily for CFML. FW/1 itself provides MVC, DI/1 provides dependency injection (a.k.a. inversion of control), and AOP/1 provides aspect-oriented programming features on top of DI/1.","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/documentation/3.5/using-aop-one/"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<meta name="theme-color" content="#157878" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
	<link rel="stylesheet" href="/assets/css/style.css?v=a3debbe0e02ab81ebdefec1b0e258acd9a63d866" />
	<link href="/atom.xml" rel="alternate" title="FW/1 - The Invisible Framework" type="application/atom+xml">
</head>
<body>
	<a id="skip-to-content" href="#content">Skip to the content.</a>

	<header class="page-header" role="banner">
		<h1 class="project-name">Using AOP/1</h1>
		<h2 class="project-tagline">Framework One - is a family of small, lightweight, convention-over-configuration frameworks, primarily for CFML. FW/1 itself provides MVC, DI/1 provides dependency injection (a.k.a. inversion of control), and AOP/1 provides aspect-oriented programming features on top of DI/1.</h2>
		
		<a href="/" class="btn">Home</a>
		<a href="/blog" class="btn">Blog</a>
		<a href="/documentation" class="btn">Documentation</a>
		
			<a href="https://github.com/framework-one/fw1/" class="btn" target="_blank">View on GitHub</a>
		
		
			<a href="https://github.com/framework-one/fw1/archive/master.zip" class="btn">Download 4.2 (Current)</a>
			<a href="https://github.com/framework-one/fw1/archive/v4.3.0-beta.1.zip" class="btn">Download 4.3 (Beta)</a>
		
		
			<a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS" class="btn">RSS</a>
		
	</header>

	<main id="content" class="main-content" role="main">
		<aside class="documentation-nav">
	<section>
		<a href="/documentation/changelog">Changelog</a><br />
		<a href="/documentation/roadmap/">Roadmap</a><br />
	</section>
	<section>
		<h3>4.3 Documentation (beta)</h3>
		<a href="/documentation/4.3/">Getting Started Guide</a><br />
		<a href="/documentation/4.3/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/4.3/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/4.3/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/4.3/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/4.3/reference-manual/">Reference Manual</a><br />
		<a href="/documentation/4.3/changelog/">Change Log</a><br />
	</section>
	<section>
		<h3>4.2 Documentation (Current Master)</h3>
		<a href="/documentation/4.2/">Getting Started Guide</a><br />
		<a href="/documentation/4.2/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/4.2/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/4.2/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/4.2/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/4.2/reference-manual/">Reference Manual</a><br />
		<a href="/documentation/4.2/changelog/">Change Log</a><br />
	</section>
	<section>
		<h3>4.1 Documentation</h3>
		<a href="/documentation/4.1/">Getting Started Guide</a><br />
		<a href="/documentation/4.1/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/4.1/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/4.1/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/4.1/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/4.1/reference-manual/">Reference Manual</a><br />
		<a href="/documentation/4.1/changelog/">Change Log</a><br />
	</section>
	<section>
		<h3>4.0 Documentation</h3>
		<a href="/documentation/4.0/">Getting Started Guide</a><br />
		<a href="/documentation/4.0/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/4.0/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/4.0/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/4.0/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/4.0/reference-manual/">Reference Manual</a><br />
		<a href="/documentation/4.0/changelog/">Change Log</a><br />
	</section>
	<section>
		<h3>3.5 Documentation</h3>
		<a href="/documentation/3.5/">Getting Started Guide</a><br />
		<a href="/documentation/3.5/cfml-and-clojure/">CFML and Clojure</a><br />
		<a href="/documentation/3.5/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/3.5/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/3.5/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/3.5/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/3.5/reference-manual/">Reference Manual</a><br />
	</section>
	<section>
		<h3>3.1 Documentation</h3>
		<a href="/documentation/3.1/">Getting Started Guide</a><br />
		<a href="/documentation/3.1/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/3.1/using-aop-one/">Using AOP/1</a><br />
		<a href="/documentation/3.1/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/3.1/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/3.1/reference-manual/">Reference Manual</a><br />
	</section>
	<section>
		<h3>3.0 Documentation</h3>
		<a href="/documentation/3.0/">Getting Started Guide</a><br />
		<a href="/documentation/3.0/developing-applications/">Developing Applications Guide</a><br />
		<a href="/documentation/3.0/using-di-one/">Using DI/1</a><br />
		<a href="/documentation/3.0/using-subsystems/">Using Subsystems</a><br />
		<a href="/documentation/3.0/reference-manual/">Reference Manual</a><br />
	</section>
</aside>

<article>
	<p>AOP/1 is a simple Aspect Oriented Programming extension for <a href="using-di-one.html">DI/1 (a.k.a Inject One)</a> which allows you to define interceptors for your beans.</p>

<p>These interceptors can run code before or after a method is called on a bean without the need for you to alter the code in your bean.  This allows you to create generic services (such as a logger service) that is coded and configured to operate completely separate from your other services and beans.  What this means is you no longer need to mix unrelated service code together by using dedicated interceptors.</p>

<p><em>The information below assumes that you already have a good working knowledge of DI/1.</em></p>

<ul id="markdown-toc">
  <li><a href="#getting-started-with-aop1" id="markdown-toc-getting-started-with-aop1">Getting Started with AOP/1</a>    <ul>
      <li><a href="#creating-interceptors" id="markdown-toc-creating-interceptors">Creating Interceptors</a>        <ul>
          <li><a href="#before-interceptors" id="markdown-toc-before-interceptors">Before Interceptors</a></li>
          <li><a href="#after-interceptors" id="markdown-toc-after-interceptors">After Interceptors</a></li>
          <li><a href="#onerror-interceptors" id="markdown-toc-onerror-interceptors">onError Interceptors</a></li>
          <li><a href="#around-interceptors" id="markdown-toc-around-interceptors">Around Interceptors</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#advanced-usage--understanding" id="markdown-toc-advanced-usage--understanding">Advanced Usage &amp; Understanding</a>    <ul>
      <li><a href="#loading-interceptors-via-configuration" id="markdown-toc-loading-interceptors-via-configuration">Loading Interceptors Via Configuration</a></li>
      <li><a href="#helper-methods" id="markdown-toc-helper-methods">Helper Methods</a></li>
      <li><a href="#intercepting-cross-object-calls--private-methods" id="markdown-toc-intercepting-cross-object-calls--private-methods">Intercepting Cross Object Calls &amp; Private Methods</a></li>
      <li><a href="#multiple-interceptor" id="markdown-toc-multiple-interceptor">Multiple Interceptor</a></li>
      <li><a href="#stack-execution" id="markdown-toc-stack-execution">Stack Execution</a></li>
    </ul>
  </li>
</ul>

<h1 id="getting-started-with-aop1">Getting Started with AOP/1</h1>

<p>Create an instance of the AOP/1 extended DI/1 bean factory and specify the folder(s) you want it to search for beans.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var beanFactory = new framework.aop("/model");
</code></pre></div></div>

<p>So far nothing difficult since this is what we would typically see from <a href="using-di-one.html">DI/1</a>.  Now, if we want to intercept method calls to an object, we need to declare the interceptors and the objects that should be intercepted.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var beanFactory = new framework.aop("/model");

beanFactory.intercept("pdfService", "beforeInterceptor");
beanFactory.intercept("pdfService", "afterInterceptor", "createDocument");

var ps = beanFactory.getBean("pdfService");

var document = ps.createDocument("http://seancorfield.github.io");
var pages = ps.splitPages(document);
</code></pre></div></div>

<p>In this example the <code class="language-plaintext highlighter-rouge">beforeInterceptor</code> will intercept every call to the <code class="language-plaintext highlighter-rouge">pdfService()</code>, but the <code class="language-plaintext highlighter-rouge">afterInterceptor</code> will only intercept calls to the <code class="language-plaintext highlighter-rouge">createDocument()</code> method. Due to AOP/1 creating intercept points on the bean being intercepted, it is generally recommended to list the methods to be intercepted when declaring the interceptors so there are not unnecessary calls made on other methods.</p>

<h2 id="creating-interceptors">Creating Interceptors</h2>

<p>A common practice for DI/1 is to place beans and services within a model folder like so:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">/model/beans/</code></li>
  <li><code class="language-plaintext highlighter-rouge">/model/services/</code></li>
</ul>

<p>Interceptors can follow this pattern in order to make it simple for the factory to locate the interceptors with the rest of the model.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">/model/interceptors/</code></li>
</ul>

<h3 id="before-interceptors">Before Interceptors</h3>

<p>Before interceptors will intercept method calls <em>before</em> they are executed.  They cannot affect the result of a method call, but they can be used to alter the arguments going to the method call and they can perform operation that you wish to be performed before the method call.  In order for an interceptor to operate as a before interceptor, it only needs the <code class="language-plaintext highlighter-rouge">before()</code> method to be defined.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>component {
    function before(targetBean, methodName, args) {
        arguments.args.input = "before" &amp; arguments.args.input;
    }
}
</code></pre></div></div>

<p>Because the interceptor is like any other bean handled by DI/1, dependencies can be intjected into the interceptor and used by the interceptor.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>component {
    property logService;

    function before(targetBean, methodName, args) {
        getLogService().logMethodCall(arguments.methodName, arguments.args);
    }
}
</code></pre></div></div>

<h3 id="after-interceptors">After Interceptors</h3>

<p>Just like the name implies, after interceptors will intercept method calls <em>after</em> they are executed.  They cannot affect the arguments going to the method call, but they can monitor or alter the result of the method call.  In order for an interceptor to operate as an after interceptor, it only needs the <code class="language-plaintext highlighter-rouge">after()</code> method to be defined.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>component {
    property logService;

    function after(targetBean, methodName, args, result) {
        if (structKeyExists(arguments, "result) &amp;&amp; !isNull(arguments.result) {
            getLogService().logMethodCallResult(arguments.methodName, arguments.args, arguments.result);
        }
    }
}
</code></pre></div></div>

<p>Should you wish to alter the result being returned, all that is needed is to return something from the <code class="language-plaintext highlighter-rouge">after()</code> method.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>component {
    function after(targetBean, methodName, args, result) {
        if (structKeyExists(arguments, "result) &amp;&amp; !isNull(arguments.result) {
            return arguments.result &amp; "After";
        }
    }
}
</code></pre></div></div>

<h3 id="onerror-interceptors">onError Interceptors</h3>

<p>onError interceptors allow errors that occur during the execution of intercepted method calls to be handled outside the normal flow of model execution.  This can be used for situations where the normal error handling of your application will not produce the desired result.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>component {
    property logService;

    function onError(targetBean, methodName, args, exception) {
        getLogService().logException(arguments.methodName, arguments.args, arguments.exception);
    }
}
</code></pre></div></div>

<h3 id="around-interceptors">Around Interceptors</h3>

<p>Around interceptors are an interesting interceptor, because unlike other interceptor types, an around interceptor can actually stop execution of an intercepted method.  This accomplished because, unlike before, after, and onError interceptors which are called externally in the order they are defined in their stacks, the around interceptors always call the next interceptor in their stack.</p>

<p>Calling the next interceptor in the stack for around interceptors is accomplished by calling the <code class="language-plaintext highlighter-rouge">proceed()</code> method.  The <code class="language-plaintext highlighter-rouge">proceed()</code> method is automatically added to any interceptor that has an <code class="language-plaintext highlighter-rouge">around()</code> method.  An around interceptor can stop the execution chain by simply not calling the <code class="language-plaintext highlighter-rouge">proceed()</code> method.  The around interceptors can preform the actions of both before and after interceptors as well.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>component {
    property logService;
    property userService;

    function around(targetBean, methodName, args) {
        // Perform 'before' arguments manipulation.
        arguments.args.name = getUserService().getCurrentUser().getName();

        if (getUserService().getCurrentUser().hasPermission("administrator")) {
            var result = proceed(arguments.targetBean, arguments.methodName, arguments.args);

            if (!isNull(result))
            {
                getLogService().logMethodCallResult(arguments.methodName, arguments.args, result);

                    return result;
                }
        }
    }
}
</code></pre></div></div>

<p>Since an around interceptor may intercept multiple methods, the method must be able to handle any type of result being returned (including void/null).  The example above demonstrates handling when a result is present and demonstrates how the execution chain can be stopped by not calling the <code class="language-plaintext highlighter-rouge">proceed()</code> method if the current user is not an ‘administrator’.</p>

<h1 id="advanced-usage--understanding">Advanced Usage &amp; Understanding</h1>

<p>The following section explains additional features and concepts that may prove useful when implementing AOP/1.</p>

<h2 id="loading-interceptors-via-configuration">Loading Interceptors Via Configuration</h2>

<p>AOP/1 extends DI/1 so it has access to the <code class="language-plaintext highlighter-rouge">config</code> parameter of the constructor.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var interceptors = [{beanName = "stringUtilityService", interceptorName = "afterInterceptor"}];
var factory = new framework.aop(folders, {interceptors = interceptors});
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">interceptors</code> configuration is just an array of structures that define the interceptors to be loaded like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var interceptors =
[
    {beanName = "stringUtilityService", interceptorName = "beforeInterceptor", methods = "forward,reverse,split"},
    {beanName = "stringUtilityService", interceptorName = "afterInterceptor"},
    {beanName = "stringUtilityService", interceptorName = "afterInterceptor2", methods = ""},
    {beanName = "stringUtilityService", interceptorName = "afterInterceptor3", methods = "*"},
    {beanName = "stringUtilityService", interceptorName = "aroundInterceptor", methods = "reverse"}
];
</code></pre></div></div>

<p>When the <code class="language-plaintext highlighter-rouge">methods</code> key is missing from the interceptor definition or it contains an empty value or asterisk, then AOP/1 assumes that all methods on the bean should be intercepted.</p>

<h2 id="helper-methods">Helper Methods</h2>

<p><code class="language-plaintext highlighter-rouge">isLast()</code>
This method is automatically added to any <strong>around</strong> interceptor and will tell you if the interceptor is the last in the execution chain.</p>

<p><code class="language-plaintext highlighter-rouge">translateArgs(any targetBean, string methodName, struct args, boolean replace)</code>
This method is automatically added to any interceptor and will attempt translate position based arguments into name based arguments.  This method has a <code class="language-plaintext highlighter-rouge">replace</code> argument that when set to <code class="language-plaintext highlighter-rouge">true</code> will replace the <code class="language-plaintext highlighter-rouge">args</code> with a copy of named arguments.</p>

<h2 id="intercepting-cross-object-calls--private-methods">Intercepting Cross Object Calls &amp; Private Methods</h2>

<p>Unlike some other AOP frameworks, AOP/1 has the ability to intercept cross object calls.  What this means is, if you are intercepting methods (<code class="language-plaintext highlighter-rouge">method1()</code>, <code class="language-plaintext highlighter-rouge">method2()</code>, <code class="language-plaintext highlighter-rouge">method3()</code>) on <code class="language-plaintext highlighter-rouge">myService</code> and <code class="language-plaintext highlighter-rouge">method2()</code> actually makes a call to <code class="language-plaintext highlighter-rouge">method3()</code>, then AOP/1 will intercept the call from <code class="language-plaintext highlighter-rouge">method2()</code> to <code class="language-plaintext highlighter-rouge">method3()</code> in addition to original call to <code class="language-plaintext highlighter-rouge">method2</code>.</p>

<p>In addition to intercepting cross object method calls, AOP/1 can also intercept calls to private methods.</p>

<h2 id="multiple-interceptor">Multiple Interceptor</h2>

<p>You may find yourself creating an interceptor that performs multiple similar tasks and it is logical to group multiple different interceptor types together.  This can be accomplished by simply creating the correct methods in the same component.  For instance, if you have an interceptor that you want to perform both before and after interceptions, then you simply add both the <code class="language-plaintext highlighter-rouge">before()</code> and <code class="language-plaintext highlighter-rouge">after()</code> methods to the component.  AOP/1 will place an interceptor in multiple execution stacks if it has more than one interceptor type method present.</p>

<h2 id="stack-execution">Stack Execution</h2>

<p>Stacks are executed in the following order.</p>

<ul>
  <li><strong>before</strong></li>
  <li><strong>around</strong></li>
  <li><strong>after</strong></li>
  <li><strong>onError</strong></li>
</ul>

<p>All the stacks will only execute if there is an interceptor of their type present.  If the stack is emtpy, nothing is executed.  The <strong>onError</strong> stack only executes if there is an error in the execution of the other stacks.  The <strong>before</strong> and <strong>after</strong> stacks execute like a queue and will execute from start to finish regardless of changes to the arguments or result, skipping any interceptors that do not match the currently intercepted bean method.  The <strong>around</strong> stack executes more like a chain.  The chain execution can be stopped by not calling the <code class="language-plaintext highlighter-rouge">proceed()</code> method.</p>


</article>

		<footer class="site-footer">
			
				<span class="site-footer-owner"><a href="https://github.com/sneiland/sneiland.github.io">sneiland.github.io</a> is maintained by <a href="https://github.com/sneiland">sneiland</a>.</span>
			
		</footer>
	</main>
</body>
</html>