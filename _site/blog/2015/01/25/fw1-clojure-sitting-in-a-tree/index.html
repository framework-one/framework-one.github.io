<!DOCTYPE html>
<html lang="en-US">
<head>
	
	<meta charset="UTF-8">

	<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>FW/1 &amp; Clojure Sitting in Tree | FW/1 - The Invisible Framework</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="FW/1 &amp; Clojure Sitting in Tree" />
<meta name="author" content="Sean Corfield" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Anyone following my tech trajectory will know that, after starting to learn Clojure in 2010, I’ve moved increasingly away from CFML and toward Clojure. In 2014, my team decided that Clojure would be our official primary language and all new development would happen there instead of in CFML. We still have a lot of CFML code in production - about 90kloc - but we consider it “legacy code” at this point. Most of that CFML code is a large ColdBox app that we built about five years ago (technically it’s three ColdBox apps but they share a lot of code). Our application Model has been slowly moving to Clojure so that we can reuse that code in new applications we’re building in Clojure. We’ve also been building new apps with FW/1 (and reusing both our CFML code and our Clojure code). We still like CFML as a templating language for views and our controllers - in our FW/1 apps at least - are often mostly just “glue” code that lets us call into our Clojure model code." />
<meta property="og:description" content="Anyone following my tech trajectory will know that, after starting to learn Clojure in 2010, I’ve moved increasingly away from CFML and toward Clojure. In 2014, my team decided that Clojure would be our official primary language and all new development would happen there instead of in CFML. We still have a lot of CFML code in production - about 90kloc - but we consider it “legacy code” at this point. Most of that CFML code is a large ColdBox app that we built about five years ago (technically it’s three ColdBox apps but they share a lot of code). Our application Model has been slowly moving to Clojure so that we can reuse that code in new applications we’re building in Clojure. We’ve also been building new apps with FW/1 (and reusing both our CFML code and our Clojure code). We still like CFML as a templating language for views and our controllers - in our FW/1 apps at least - are often mostly just “glue” code that lets us call into our Clojure model code." />
<link rel="canonical" href="http://localhost:4000/blog/2015/01/25/fw1-clojure-sitting-in-a-tree/" />
<meta property="og:url" content="http://localhost:4000/blog/2015/01/25/fw1-clojure-sitting-in-a-tree/" />
<meta property="og:site_name" content="FW/1 - The Invisible Framework" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-01-25T16:30:49-05:00" />
<script type="application/ld+json">
{"headline":"FW/1 &amp; Clojure Sitting in Tree","dateModified":"2015-01-25T16:30:49-05:00","datePublished":"2015-01-25T16:30:49-05:00","url":"http://localhost:4000/blog/2015/01/25/fw1-clojure-sitting-in-a-tree/","author":{"@type":"Person","name":"Sean Corfield"},"description":"Anyone following my tech trajectory will know that, after starting to learn Clojure in 2010, I’ve moved increasingly away from CFML and toward Clojure. In 2014, my team decided that Clojure would be our official primary language and all new development would happen there instead of in CFML. We still have a lot of CFML code in production - about 90kloc - but we consider it “legacy code” at this point. Most of that CFML code is a large ColdBox app that we built about five years ago (technically it’s three ColdBox apps but they share a lot of code). Our application Model has been slowly moving to Clojure so that we can reuse that code in new applications we’re building in Clojure. We’ve also been building new apps with FW/1 (and reusing both our CFML code and our Clojure code). We still like CFML as a templating language for views and our controllers - in our FW/1 apps at least - are often mostly just “glue” code that lets us call into our Clojure model code.","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/2015/01/25/fw1-clojure-sitting-in-a-tree/"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<meta name="theme-color" content="#157878" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
	<link rel="stylesheet" href="/assets/css/style.css?v=a3debbe0e02ab81ebdefec1b0e258acd9a63d866" />
	<link href="/atom.xml" rel="alternate" title="FW/1 - The Invisible Framework" type="application/atom+xml">
</head>
<body>
	<a id="skip-to-content" href="#content">Skip to the content.</a>

	<header class="page-header" role="banner">
		<h1 class="project-name">FW/1 & Clojure Sitting in Tree</h1>
		<h2 class="project-tagline">Framework One - is a family of small, lightweight, convention-over-configuration frameworks, primarily for CFML. FW/1 itself provides MVC, DI/1 provides dependency injection (a.k.a. inversion of control), and AOP/1 provides aspect-oriented programming features on top of DI/1.</h2>
		
		<a href="/" class="btn">Home</a>
		<a href="/blog" class="btn">Blog</a>
		<a href="/documentation" class="btn">Documentation</a>
		
			<a href="https://github.com/framework-one/fw1/" class="btn" target="_blank">View on GitHub</a>
		
		
			<a href="https://github.com/framework-one/fw1/archive/master.zip" class="btn">Download 4.2 (Current)</a>
			<a href="https://github.com/framework-one/fw1/archive/v4.3.0-beta.1.zip" class="btn">Download 4.3 (Beta)</a>
		
		
			<a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS" class="btn">RSS</a>
		
	</header>

	<main id="content" class="main-content" role="main">
		<hr style="clear:both"/>

<article class="hentry" role="article">
	<p>Anyone following my tech trajectory will know that, after starting to learn Clojure in 2010, I’ve moved increasingly away from CFML and toward Clojure. In 2014, my team decided that Clojure would be our official primary language and all new development would happen there instead of in CFML. We still have a lot of CFML code in production - about 90kloc - but we consider it “legacy code” at this point. Most of that CFML code is a large ColdBox app that we built about five years ago (technically it’s three ColdBox apps but they share a lot of code). Our application Model has been slowly moving to Clojure so that we can reuse that code in new applications we’re building in Clojure. We’ve also been building new apps with FW/1 (and reusing both our CFML code and our Clojure code). We still like CFML as a templating language for views and our controllers - in our FW/1 apps at least - are often mostly just “glue” code that lets us call into our Clojure model code.<!-- more --></p>

<p>I’ve talked in passing on the FW/1 mailing list about the possibility of deeper integration with Clojure and I recently published <a href="https://github.com/framework-one/cfmljure/releases/tag/v0.1.0">cfmljure 0.1.0</a> - which I’ll be blogging about shortly - and so the topic came up again on the mailing list about this integration. I’d been thinking about how to write controllers in Clojure so that you could have a FW/1 app that used CFML for the views - where it excels as a templating language - and Clojure for the controllers and the model, leveraging the expressive power and immutable safety for all your business logic.</p>

<p>Over the last few days, I created a fork of FW/1 3.0 that included cfmljure and built a proof of concept of Clojure controllers. You can take a look at the <a href="https://github.com/framework-one/fw1/tree/clojure/examples/6helloclojure">FW/1 example with Clojure controllers</a> on the <code class="language-plaintext highlighter-rouge">clojure</code> branch of the FW/1 repo. I created the project using Leiningen (Clojure’s build tool) and then added <code class="language-plaintext highlighter-rouge">Application.cfc</code>, <code class="language-plaintext highlighter-rouge">index.cfm</code>, and the <code class="language-plaintext highlighter-rouge">views/</code> tree. Then I wrote the <code class="language-plaintext highlighter-rouge">controllers/main.clj</code> file (in <code class="language-plaintext highlighter-rouge">src/hello</code>) and the <code class="language-plaintext highlighter-rouge">controllers_test.clj</code> test file (in <code class="language-plaintext highlighter-rouge">test/hello</code>). Unit testing is built in, so you can run <code class="language-plaintext highlighter-rouge">lein test</code> to see the results. Then I refactored the Clojure code (creating the separate <code class="language-plaintext highlighter-rouge">greet.clj</code> file) and added a “service” in Clojure just for fun. The FW/1 app uses <code class="language-plaintext highlighter-rouge">framework.ioclj</code> - a extended version of DI/1 that uses cfmljure - to auto-discover the Clojure code (and the CFML code - you can mix’n’match) and wraps the Clojure controllers in <code class="language-plaintext highlighter-rouge">framework.cljcontroller</code> (to adapt to Clojure’s pure function calling convention, and to handle some FW/1-specific functionality). The CFML views are run as usual (and if you look in <code class="language-plaintext highlighter-rouge">views/main/default.cfm</code> you’ll see a call to the Clojure “service” via the bean factory: <code class="language-plaintext highlighter-rouge">getBeanFactory().getBean("greeterService").greetings("Earthling!")</code>).</p>

<p>I’m rather excited about this because it means we’ll have a way, at work, to further migrate our model code from CFML to Clojure, while maintaining “legacy” CFML code alongside, <em>right there in the same FW/1 application!</em></p>

<p>This won’t be part of FW/1 3.0. Instead it will stay on the <code class="language-plaintext highlighter-rouge">clojure</code> branch until release 3.0 is out (<code class="language-plaintext highlighter-rouge">develop</code> will be merged to <code class="language-plaintext highlighter-rouge">master</code> for that), but it will be part of FW/1 3.5 which will be the next release. That way it can get some field testing in production as well as some polish and some documentation love. Stay tuned!</p>

<p>p.s. Right now cfmljure only runs on Railo. The CFML code itself could be made portable enough to run on ColdFusion but the real problem is interop with Java/Clojure: ColdFusion thinks 42 is a string and so you need to do a lot of string-to-number conversions to interact with Clojure through cfmljure. I haven’t used ColdFusion for over five years - just Railo - so I don’t have much incentive, but if you feel inclined to send a Pull Request with changes to make cfmljure ColdFusion-compatible…</p>

<p>p.p.s. cfmljure now runs on Adobe ColdFusion 11, Lucee, and Railo! Thanks to Andrew Myers for tackling ColdFusion support.</p>

	<footer>
		<p class="meta">
			
<span class="byline author vcard">Posted by <span class="fn">Sean Corfield</span></span>

			





			<div>
				

<span class="categories">
	
		
			<a href="/blog/category/fw1">fw1</a>
			,
		
			<a href="/blog/category/clojure">clojure</a>
			
		
  
</span>


			</div>
		</p>
    
		
	<div class="sharing">
		
		
		
	</div>

	
		<p class="meta">
			
				<a class="basic-alignment left" href="/blog/2015/01/25/fw1-3-0-rc-1-available/" title="Previous Post: FW/1 3.0 RC 1 available">&laquo; FW/1 3.0 RC 1 available</a>
			
			
				<a class="basic-alignment right" href="/blog/2015/01/29/lucee-fw1/" title="Next Post: Lucee and FW/1">Lucee and FW/1 &raquo;</a>
			
		</p>
	
		
<section>
	<h1>Comments</h1>
	<div id="disqus_thread" aria-live="polite">
		<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
		
		<script type="text/javascript">
			var disqus_shortname = 'framework-one';
			
				
				// var disqus_developer = 1;
				var disqus_identifier = 'http://localhost:4000/blog/2015/01/25/fw1-clojure-sitting-in-a-tree/';
				var disqus_url = 'http://localhost:4000/blog/2015/01/25/fw1-clojure-sitting-in-a-tree/';
				var disqus_script = 'embed.js';
			
			(function () {
					var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
					dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
					(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
			}());
		</script>
	</div>
</section>
	
	</footer>
</article>

		<footer class="site-footer">
			
				<span class="site-footer-owner"><a href="https://github.com/sneiland/sneiland.github.io">sneiland.github.io</a> is maintained by <a href="https://github.com/sneiland">sneiland</a>.</span>
			
		</footer>
	</main>
</body>
</html>