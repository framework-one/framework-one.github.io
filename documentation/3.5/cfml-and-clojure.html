
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Using Clojure With CFML - FW/1 - The Invisible Framework</title>
  <meta name="author" content="Sean Corfield">

  
  <meta name="description" content="Using Clojure With CFML Jul 12th, 2015 This is the upcoming (3.5 &ndash; clojure) documentation &ndash; for the current stable release, read the 3.1 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://framework-one.github.io/documentation/3.5/cfml-and-clojure.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="FW/1 - The Invisible Framework" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">FW/1 - The Invisible Framework</a></h1>
  
    <h2>Framework One and friends...</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:framework-one.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">Blog</a></li>
    <li><a href="/blog/archives">Archives</a></li>
    <li><a href="/documentation">Documentation</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article role="article">
  
  <header>
    <h1 class="entry-title">Using Clojure With CFML</h1>
    <p class="meta">








  


<time datetime="2015-07-12T21:40:00-07:00" pubdate data-updated="true">Jul 12<span>th</span>, 2015</time></p>
  </header>
  
  <p><em>This is the upcoming (3.5 &ndash; clojure) documentation &ndash; for the current stable release, read the <a href="/documentation/3.1/">3.1 master stable documentation</a>.</em></p>

<h1>Clojure and CFML Sitting in a tree</h1>

<p>Back in 2010, I started to learn Clojure. It&rsquo;s a Lisp that runs on the JVM. It&rsquo;s a mostly pure functional programming language.
It&rsquo;s very simple &mdash; very little syntax &mdash; but very powerful and expressive. It has a thriving community and ecosystem. Being a
functional programming language it favors immutable data structures and higher order functions (map, filter, reduce, etc) which
makes programs easy to reason about and it also makes concurrent programming pretty easy. No more thread safety issues!</p>

<p>Although Clojure can be compiled to JVM bytecode and deployed as a JAR or WAR file, it can also be treated like
a dynamic scripting language and compiled on-the-fly to JVM bytecode, just like CFML, giving you that very fast edit-reload-test
cycle that you&rsquo;re used to with CFML. In fact, if you use the REPL (Read-Eval-Print-Loop) you can pretty much reduce that to
just edit-test since Clojure code is compiled as you type it in and can be evaluated immediately.</p>

<p>Because I was still writing a lot of CFML back in 2010, I figured out an easy way to allow you, as a CFML developer, to load
and run Clojure code within your CFML application. That functionality has been available via the standalone
<a href="https://github.com/framework-one/cfmljure">cfmljure library</a> for several years, and it has become core
to how the Internet dating platform works at my company (<a href="http://worldsinglesnetworks.com">World Singles Networks</a>). We&rsquo;ve had
<strong>cfmljure</strong> in production since Spring 2011 and, in 2014, we declared Clojure to be our primary language and nearly all new
development happens in Clojure, hosted within three ColdBox applications and two FW/1 applications. Clojure powers all of our
standalone processes as well.</p>

<p>As we&rsquo;ve come to depend on FW/1 more and more, I&rsquo;ve wanted to streamline the integration between FW/1 and <strong>cfmljure</strong> so that
we can write services in Clojure and have them autowired into our controllers, just like our CFML services are, as well as have
the option to write controllers in Clojure (where all the code they call is Clojure, not CFML).</p>

<p>That&rsquo;s why, in FW/1 3.5, I&rsquo;ve made <strong>cfmljure</strong> part of the standard distribution and provided an extenion to DI/1 to allow
Clojure code to be discovered and autowired into your CFML code, as well as a way to write FW/1 controllers in pure Clojure.</p>

<h2>Some Important Caveats (and System Requirements)</h2>

<p>Before you get started, there are a couple of things you need to be aware of:</p>

<ul>
<li>The Clojure integration works best on <strong>Lucee</strong> (4.5 or later) or <strong>Railo</strong> (4.2). ColdFusion 11 is supported too but interop between CFML and Clojure
can get pretty ugly (see the <a href="https://github.com/framework-one/cfmljure/blob/master/index-acf.cfm">ColdFusion-specific examples</a>
in the <strong>cfmljure</strong> project repo for more details). I doubt it will run on ColdFusion 10 or earlier. I developed exclusively
on Railo from 2009 to 2015 and now I develop on Lucee. Thank <a href="https://github.com/am2605">Andrew Myers</a> for the ColdFusion 11
support!</li>
<li>You should be running <strong>Java 8</strong> at this point. The Clojure integration <em>will not work on Java 6</em>. It has not been tested on Java 7.
The Java 6 EOL notice was February 2011 and public updates stopped in February 2011. The Java 7 EOL notice was March 2014 and public
updates stopped in April 2015.</li>
<li>Clojure developers are pretty comfortable at the command line, so the build tool you&rsquo;ll need to install for this is a command
line tool: be prepared to work in Terminal / Console quite a bit!</li>
<li>Clojure developers use editors that auto-close parentheses, brackets, and braces. Most of those editors also support &ldquo;structural
editing&rdquo; which means they understand expressions enclosed in matched pairs of parentheses (or brackets or braces) and let you
easily manipulate <em>expressions</em> rather than just text. There are plugins for Eclipse, Sublime Text, IntelliJ and several others.
Most Clojure developers use Emacs or Vim. I use Emacs for all my editing, CFML included.</li>
<li>In order to use Clojure with CFML, you <strong>must not run your CFML server under the root account</strong> (on Mac or Linux). It&rsquo;s something
you should never do in production anyway for security reasons, and there&rsquo;s really no reason to do it on your development machine
either. <strong>cfmljure</strong> checks this for you and refuses to initialize (and throws a helpful exception).</li>
<li>For ease of debugging any problems that may occur, I <em>strongly</em> recommend you always keep a Terminal / Console window open
containing a tail of the console output from your CFML server. If you&rsquo;re using Lucee or a Railo installation based on Tomcat,
you&rsquo;ll want to find the <code>catalina.out</code> log file and tail that. If you&rsquo;re using ColdFusion 11, even tho&#8217; it is notionally based
on Tomcat, it&rsquo;s completely non-standard and you&rsquo;ll want to tail <code>cfusion/logs/coldfusion-out.log</code>.</li>
<li>Finally, <strong>cfmljure</strong> uses a lock file to ensure that a couple of things it does during initialization are single-threaded
across the whole server, no matter how your CFML server and application instances are configured. On Mac and Linux, it
creates (and deletes) <code>/tmp/cfmljure.lock</code>. On Windows, it creates (and deletes) <code>cfmljure.lock</code> in your <code>TEMP</code> folder which
is normally in the <code>AppData</code> folder off your local accounts home folder &mdash; check your <code>TEMP</code> environment variable for the
exact location. <strong>cfmljure</strong> tries really hard to clean up after itself but if something goes badly wrong during initialization,
it&rsquo;s possible the lock file will be left behind and you will need to manually delete it. <strong>cfmljure</strong> will try its best to
let you know if it needs you to delete the lock file &mdash; but if you&rsquo;re tailing the logs, you&rsquo;ll see messages as the
initialization proceeds.</li>
</ul>


<h2>Getting Started with Clojure and CFML</h2>

<p>Clojure has a standard build tool called <a href="http://leiningen.org">Leiningen</a>. This manages all of your project dependencies
(e.g., automatically downloading and installing any libraries you need) as well as providing a REPL for
interactive development, running your tests, packaging applications into JAR files, deploying them to standard repositories and so on.</p>

<p><strong>cfmljure</strong> leverages <strong>Leiningen</strong> to figure out the complete classpath that your Clojure code needs &mdash; including any
libraries you use &mdash; so that it can easily load all the JAR files (and Clojure source code) into your CFML server.</p>

<h3>Leiningen</h3>

<p>That means the first step to using FW/1 and Clojure together is to install <strong>Leiningen</strong> and make sure it is working.</p>

<p>If you&rsquo;re on Mac or Linux, follow the <a href="http://leiningen.org/#install">Leiningen Install steps</a> for the <code>lein</code> shell script.</p>

<p>If you&rsquo;re on Windows, I recommend using the <a href="http://leiningen-win-installer.djpowell.net/">Installer for Windows users</a> mentioned
near the end of that <strong>Install</strong> section.</p>

<p>Once you have it installed, open up a new Terminal / Console window and navigate to directory where you can create a project to
test that it is working properly, then do this:</p>

<pre><code>lein new app myapp
</code></pre>

<p>It will probably download a bunch of libraries the first time you run it, but it should (eventually) respond:</p>

<pre><code>Generating a project called myapp based on the 'app' template.
</code></pre>

<p>Now go into that project and run it:</p>

<pre><code>cd myapp
lein run
</code></pre>

<p>It should say:</p>

<pre><code>Hello, World!
</code></pre>

<p>Congratulations! <strong>Leiningen</strong> is installed and working!</p>

<p>BTW, <strong>Leiningen</strong> supports unit testing out of the box, so in addition to creating an application skeleton for <code>myapp</code>,
it also generates a test skeleton which you can run like this:</p>

<pre><code>lein test
</code></pre>

<p>Because the test skeleton doesn&rsquo;t have any valid tests &mdash; just one deliberate failure &mdash; you should see:</p>

<pre><code>lein test myapp.core-test

lein test :only myapp.core-test/a-test

FAIL in (a-test) (core_test.clj:7)
FIXME, I fail.
expected: (= 0 1)
  actual: (not (= 0 1))

Ran 1 tests containing 1 assertions.
1 failures, 0 errors.
Tests failed.
</code></pre>

<p>When you start developing services and controllers in Clojure, you&rsquo;ll find it handy to write unit tests as you go and run
them with <code>lein test</code>!</p>

<h3>Testing FW/1 3.5 and Clojure</h3>

<p>At this point you should be able to start your CFML server (remember: not under the <strong>root</strong> account!) and, with FW/1 3.5
installed (and possibly with a <code>/framework</code> mapping set up, or with the <code>framework</code> folder moved into your webroot), you
should be able to run all of the FW/1 examples. Make sure examples 1-5 work, then try <code>6helloclojure</code>.</p>

<p>If it doesn&rsquo;t seem to run correctly, and there&rsquo;s no obvious exception information in the browser or useful information in the
log file, you can try to re-run the <code>6helloclojure</code> example with <code>?cfmljure=abortOnFailure</code> added to the URL. This should
dump a whole bunch of information to the browser as well as any exception encountered.</p>

<p>If that doesn&rsquo;t help, add <code>diConfig : { debug : true }</code> to the <code>variables.framework</code> configuration in <code>Application.cfc</code> for
that example and try again. This will output more information to the CFML server&rsquo;s console log (which you&rsquo;re tailing, right?).</p>

<p>If you can&rsquo;t figure out the problem from all this extra debugging information, at least you&rsquo;ll have it all available
when you post to the FW/1 mailing list, asking for help!</p>

<p>At this point, however, I hope you got the example to run and you were able to try out the various links and see what it was
doing in the trace output in the browser, and perhaps by looking at the code, which we&rsquo;ll go over next.</p>

<h2>The 6helloclojure Example Explained</h2>

<p>If you look in the <code>6helloclojure</code> folder, you&rsquo;ll see a combination of things you expect to see in a FW/1 application and
files and folders that would see in your <code>myapp</code> Clojure test project above:</p>

<pre><code>Application.cfc index.cfm views
.gitignore LICENSE README.md doc resources target
project.clj src test
</code></pre>

<p>The files shown in the first line are for FW/1. You might later add a <code>controllers</code> folder and a <code>model</code> folder if you
write any of those pieces in CFML.</p>

<p>The files shown in the second line are generated by <strong>Leiningen</strong> and you can pretty much ignore them. You&rsquo;ll see that by
default a Leiningen-generated Clojure project is assumed to live under version control with <code>git</code>, have an open source
software license (Eclipse Public License 1.0 by default), have a readme file that explains what the project is for and
how to use it, a documentation folder, possibly some non-source code resource files (configuration files or perhaps
assets for a web application), and you may see a <code>target</code> folder which is used by <strong>Leiningen</strong> for compiling code and
generating JAR files etc.</p>

<p>The files shown in the third line are the important parts of the Clojure code:
* <code>project.clj</code> defines the dependencies of
your project (the libraries it needs), as well as any development or test tooling (as plugins) and several other
important aspects of how to run, test, and package your code. You&rsquo;ll notice that it also has a description, a URL for
where to find the project (e.g., on GitHub), and details of the license.
* <code>src</code> is where your Clojure source code lives. Clojure itself places very few restrictions on the structure of this
(beyond assuming that the file structure matches the namespace structure within the Clojure source files, much the
same way Java&rsquo;s file structure matches its package structure). If you have a Clojure namespace with <code>-</code> in its name,
the corresponding folder will have <code>_</code> in its name.
* <code>test</code> is where your Clojure test code lives. It&rsquo;s a common convention that if your source file is <code>foo/bar/baz.clj</code>
which will have a namespace of <code>foo.bar.baz</code>, then the tests for that code will live in <code>foo/bar/baz_test.clj</code> with
a namespace of <code>foo.bar.baz-test</code>. We have <code>hello/controllers/main_test.clj</code> which contains tests for the source code
in <code>hello/controllers/main.clj</code>.</p>

<p>If you run <code>lein test</code> in the <code>6helloclojure</code> folder, you&rsquo;ll see:</p>

<pre><code>lein test hello.controllers.main-test

lein test hello.services.greeter-test

Ran 2 tests containing 3 assertions.
0 failures, 0 errors.
</code></pre>

<p>We&rsquo;ll take a look at that in a minute.</p>

<p>Let&rsquo;s start with the CFML files and look at <code>Application.cfc</code> first, then the <code>views</code> folder. As usual <code>index.cfm</code> is an empty file.</p>

<h3>Application.cfc</h3>

<p>There are a few items of note here, and the first is that we specify <code>diComponent</code> as <code>"framework.ioclj"</code> to tell FW/1 that we want to use <code>ioclj.cfc</code>
rather than the default <code>ioc.cfc</code> for the Dependency Injection component (the bean factory). <code>ioclj.cfc</code> extends DI/1 and
provides the Clojure-specific magic.</p>

<p>Next we specify <code>diLocations</code> as the full filesystem path of the current folder. In a CFML / Clojure application, you need to tell the bean factory
about two things: where to find your <code>project.clj</code> file and where to look for your CFML beans (if any). Locations are specified as
either a comma-separated list of file paths, or an array of paths, and one of them must specify the exact file path to where <code>project.clj</code> lives. That will also be
searched (recursively) for CFCs so you can store both your Clojure code and your CFML beans in the same tree structure if you wish, or
you can store them separately and provide both file paths in <code>diLocations</code>.</p>

<p>The other code of note is that <code>setupRequest()</code> reloads the Clojure code whenever the framework itself is reloaded.
Normally, in
a FW/1 app, you can specify an application reload and your bean factory is recreated. Because of the way Clojure code is compiled and loaded
into the JVM, reloading your bean factory is not sufficient to force a reload of those parts of the JVM, so you need to do this programmatically
somehow. Note that this will only reload the namespaces that follow the FW/1 conventions to be discovered. See below for more on this.</p>

<h2>views</h2>

<p>This is a regular FW/1 views folder, containing a subfolder for each section of the app (just <code>main</code> in this case) and a file for each item (there are
three views here). As expected we have a <code>main.default</code> view and a <code>main.error</code> view which are basic defaults for FW/1 applications. We also have
a <code>main.stopped</code> view. We&rsquo;ll see how each of these is used when we look at the <code>main</code> controller.</p>

<p>The <code>default</code> view references <code>rc.greeting</code> which we&rsquo;ll see being set up in the <code>main.clj</code> controller below, and it also gets a <code>greeterService</code> from
the bean factory and calls a function in that. We&rsquo;ll see where <code>greeterService</code> comes from below as well.</p>

<h2>src/hello/controllers</h2>

<p>In this folder we have a single Clojure file, <code>main.clj</code>. As you might guess from the file path, this is our application controller. Inside you&rsquo;ll
see a namespace declaration (the <code>ns</code> expression) and four functions which represent our handlers.</p>

<p>As with CFML controller functions, each function is passed an argument called <code>rc</code> which is the request context. Unlike CFML controllers
which might modify elements of the <code>rc</code> struct directly,
Clojure controllers return an updated version of the <code>rc</code> data structure to the framework.</p>

<p>In the <code>default</code> handler, we get the <code>:name</code> element of the <code>rc</code> and we return <code>rc</code> with an additional element called <code>:greeting</code>. In Clojure,
<code>(:foo bar)</code> is roughly equivalent to CFML&rsquo;s <code>bar.foo</code>, and <code>(:foo bar "baz")</code> is similar to:</p>

<pre><code>structKeyExists( bar, "foo" ) ? bar.foo : "baz"
</code></pre>

<p>So <code>default</code> passes <code>rc.name</code> (or <code>"anonymous"</code> if <code>name</code> isn&rsquo;t present in <code>rc</code>) to the <code>greet/hello</code> function and then stores the result in
the <code>greeting</code> element of <code>rc</code>. Note that the <code>assoc</code> function (pronounced <em>assosh</em> like the word <em>associate</em>) return a new struct with the
key added &mdash; it does not modify the original struct. This seems very strange at first but you&rsquo;ll get used to it and it&rsquo;s very powerful (and
very safe) since <code>rc</code> is immutable. We&rsquo;ll look at where <code>greet/hello</code> comes from in a minute.</p>

<p>Next we have the <code>do-redirect</code> handler. Yes, Clojure functions can have <code>-</code> in their names. The standard naming convention in Clojure is <em>words-like-this</em>
rather than <em>wordsLikeThis</em> or <em>WordsLikeThis</em>. It&rsquo;s a long-standing Lisp tradition. Yes, it&rsquo;s strange but you&rsquo;ll get used to it and you&rsquo;ll
soon find it more readable than CamelCase. Anyway, this handler tells FW/1 to redirect to <code>main.default</code> with the specified query string.
Adding a key called <code>:redirect</code> to <code>rc</code> is the equivalent of calling <code>variables.fw.redirect()</code> in a pure CFML FW/1 app. All four arguments
to the <code>redirect()</code> function can be specified as keys in the <code>:redirect</code> struct (<code>:append</code>, <code>:preserve</code>, <code>:queryString</code>, <code>:statusCode</code>).</p>

<p>Then we have the <code>stop-it</code> handler. By the way, the URL actions that correspond to <code>do-redirect</code> and <code>stop-it</code> are <code>do_redirect</code> and
<code>stop_it</code> respectively, following the filesystem convention of swapping <code>_</code> for <code>-</code> in Clojure. This handler tells FW/1 it wants to
abort the controller cycle and also set the view to the <code>main.stopped</code> action. Adding a key called <code>:abort</code> with a value of <code>:controller</code>
is equivalent to calling <code>variables.fw.abortController()</code>. Adding a key called <code>:view</code> is equivalent to calling
<code>variables.fw.setView()</code>. You&rsquo;ll note that <code>assoc</code> can take any number of key/value pairs and add them all into the given struct.</p>

<p>Finally we have the <code>json</code> handler. By this point, it won&rsquo;t surprise you to learn that this tells FW/1 to render the specified data
as JSON. The Clojure struct <code>{:a 1 :b "two" :c [3 4 5]}</code> is equivalent to the CFML struct <code>{a : 1, b : "two", c : [3, 4, 5]}</code>.</p>

<h2>src/hello/services</h2>

<p>In this folder we have a single Clojure file, <code>greeter.clj</code>. As with the controller convention, the file path tells FW/1 that this is
a service (and it would be autowired into any CFML code that declared <code>property greeterService;</code> as a dependency). This can also be
pulled from the bean factory as <code>"greeterService"</code>, as seen in the <code>main.default</code> view file.</p>

<p>There&rsquo;s a single function <code>hello</code> in here that takes a string and returns it wrapped with <code>"Hello "</code> and <code>"!"</code>.</p>

<h2>test/hello</h2>

<p>Finally, we&rsquo;ll look at the tests, first for the <code>main</code> controller, then the <code>greeter</code> service.</p>

<p>In <code>controllers/main_test.clj</code>, we have one test function <code>default-item-test</code> which contains two related
tests. The arrow syntax means &ldquo;take this thing and pass it through these functions&rdquo; so:</p>

<pre><code>(-&gt; {} default :greeting)
</code></pre>

<p>takes an empty struct and passes it as the first argument to the <code>default</code> function (our handler method being tested) and then
pass the result to the <code>:greeting</code> function &mdash; remember that <code>(:greeting my-struct)</code> is like <code>my_struct.greeting</code> in CFML. So
this tests that if the <code>rc</code> is empty and you run <code>main.default</code> you get a new key called <code>:greeting</code> whose value is <code>"Hello anonymous!"</code>.</p>

<p>The second test checks that if <code>rc</code> contains a <code>:name</code> element, you get back the appropriate greeting based on the value of that.</p>

<p>The <code>(testing "label" ...)</code> expression can have multiple <code>is</code> tests in it, even tho&#8217; ours do not.</p>

<p>In <code>services/greeter_test.clj</code>, we again have one test function <code>hello-test</code> that verifies the <code>hello</code> function does what we expect.</p>

<h2>FW/1 Conventions with Clojure</h2>

<p>The naming and file path conventions for how you structure your Clojure code for use with FW/1 should be familiar to you if you&rsquo;ve
already used DI/1 in the past: plural folder names, containing &ldquo;components&rdquo;, become beans named for the component, with a suffix that
is the singular of the folder name:</p>

<ul>
<li><code>src/hello/controllers/main.clj</code> &ndash;> <code>mainController</code></li>
<li><code>src/hello/services/greeter.clj</code> &ndash;> <code>greeterService</code></li>
</ul>


<p>FW/1 requires that there are at least three segments in a name for this convention (so just <code>src/controllers/main.clj</code> would not
match the convention, but <code>src/hello/admin/controllers/user.clj</code> would match and become <code>userController</code>). An additional restriction
is that the filename + suffix must be unique across your whole application (within the Clojure code (so also having
<code>src/hello/public/controllers/user.clj</code> would conflict with <code>src/hello/admin/controllers/user.clj</code>).</p>

<p>Aside: You can have additional Clojure code that doesn&rsquo;t follow this convention, but the bean factory <code>reload()</code> function only attempts to
reload Clojure files that it &ldquo;knows&rdquo; about via this convention. You can explicitly reload others &mdash; if you allow for a URL variable that can
be passed to the <code>reload()</code> method of the bean factory, identifying a single namespace &mdash;
but there are some subtleties there which are beyond the scope of this
documentation (if you want to learn more, read the <a href="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/require">clojure.core/require docstring</a>
and know that <code>reload("all")</code> does <code>(require ... :reload)</code> on each namespace covered by the convention but
<code>(require ... :reload-all)</code> for an explicitly provided namespace).</p>

<h2>What is ns all about?</h2>

<p>Probably the most complex and confusing aspect when you are first learning Clojure is the <code>ns</code> expression. <code>ns</code> serves two main purposes:</p>

<ul>
<li>It declares the namespace in which the code in a given file lives.</li>
<li>It declares what additional namespaces you depend on and how you&rsquo;re going to access functions in them.</li>
</ul>


<p>Think of a namespace as a &ldquo;package&rdquo; or &ldquo;module&rdquo;. The default convention in Clojure is that the namespace matches the filesystem path below your <code>src</code>
or <code>test</code> folder, except that <code>-</code> in a namespace identifier matches <code>_</code> in the file path. Technically, a namespace can be implemented across multiple
files but it isn&rsquo;t very common to see that, so don&rsquo;t worry about it.</p>

<p>In the <code>6helloclojure</code> example, you&rsquo;ll see <code>hello.controllers.main</code> for <code>src/hello/controllers/main.clj</code> and <code>hello.controllers.main-test</code> for
<code>test/hello/controllers/main_test.clj</code>. If you follow this basic convention, you won&rsquo;t go wrong. If your <code>ns</code> declaration doesn&rsquo;t match the
filesystem path, you can get strange errors when you attempt to access it. Think of it much like the dotted-path used to access CFCs in CFML.</p>

<p>The second important part of <code>ns</code> is the list of namespaces your code <code>:require</code>s. There are two basic forms here:</p>

<ul>
<li><code>[some.namespace :as alias]</code> which lets you use <code>alias/name</code> as a way to reference any functions defined in <code>some.namespace</code>.</li>
<li><code>[some.namespace :refer [fn1 fn2]]</code> which lets you use <code>fn1</code> and <code>fn2</code> directly from <code>some.namespace</code> without a prefix. The
shorthand <code>:refer :all</code> brings in every function from that namespace, and is generally only used in test code.</li>
</ul>


<p>Prefer the first form &mdash; which you see in <code>hello.controllers.main</code> where <code>hello.services.greeter</code> is given an alias of <code>greet</code> so that
the controller can call <code>greet/hello</code>.</p>

<p>You&rsquo;ll use the <code>:require</code> expression to bring in Clojure standard libraries, 3rd party Clojure libraries, and parts of your own code. For most
3rd party libraries, you&rsquo;ll also need to add an entry to <code>:dependencies</code> in your <code>project.clj</code> file in order to tell <strong>Leiningen</strong> that you
need that library downloaded. We&rsquo;ll see this when we learn about database access below.</p>

<p>I recommend writing your required namespaces in alphabetical order &mdash; most production Clojure code relies on quite a long list of other namespaces
so organization is important.</p>

<p>You might think this sounds a bit like <code>import</code> statements in Java and you&rsquo;d be right, except that <code>:require</code> is purely for Clojure code.
There is another form for importing Java classes, called <code>:import</code>, but Java interop is a whole other subject and you should consult a
Clojure book or the online documentation for more details about that.</p>

<h1>Building Your Own CFML / Clojure Application</h1>

<p>Since we want to focus on the Clojure aspect of a combined CFML / Clojure project, we&rsquo;ll
start out by creating a Clojure project, and adding the necessary FW/1 CFML files to it
in order to create a web application.</p>

<p>We will build a very simple task manager, backed by a database. We will initially create
a CFML controller and write a Clojure service to interact with the database, then we&rsquo;ll
replace the CFML controller with a Clojure controller to wrap things up.</p>

<h2>Creating the Clojure project</h2>

<p>Our Clojure code doesn&rsquo;t need to be in our CFML webroot so just pick a folder and we&rsquo;ll create a new Clojure application, in which we&rsquo;ll write our task manager code:</p>

<pre><code>lein new app taskmanager
</code></pre>

<p>This will create a folder called <code>taskmanager</code> containing a bare bones Clojure project. It&rsquo;ll have a <code>-main</code> function so we can use it to run specific operations from the command line, and it&rsquo;ll have tests we can run to validate our code.</p>

<h2>Accessing a Database from Clojure</h2>

<p>In order to access a database (via JDBC) from Clojure, you will first need to update your <code>project.clj</code> file to include
dependencies on Clojure&rsquo;s JDBC library and what your choice of JDBC driver is. For now we&rsquo;ll use Apache Derby but if you
look at the <a href="https://github.com/clojure/java.jdbc">java.jdbc</a> page on GitHub, you&rsquo;ll see links to several other common
database drivers (if you use SQL Server, you&rsquo;ll find it easiest to use the jTDS driver to get started!).</p>

<p>Edit <code>project.clj</code> and update the <code>:dependencies</code> section to include:</p>

<pre><code>[org.apache.derby/derby "10.11.1.1"]
[org.clojure/java.jdbc "0.3.7"]
</code></pre>

<p>You&rsquo;ll now have a vector with three vectors inside it like this:</p>

<pre><code>:dependencies [[org.apache.derby/derby "10.11.1.1"]
               [org.clojure/java.jdbc "0.3.7"]
               [org.clojure/clojure "1.6.0"]]
</code></pre>

<p>Now run <code>lein repl</code> and we can try this out. As the REPL starts up, it will download the new
libraries and then you&rsquo;ll get the prompt. Let&rsquo;s create test database and write and read some
data with it:</p>

<pre><code>user&gt; (require '[clojure.java.jdbc :as sql])
nil ;; now we have the JDBC library loaded with an alias
user&gt; (def db {:subprotocol "derby" :subname "cfmltest" :create true})
#'user/db ;; this is our database spec
user=&gt; (sql/execute! db [(str "CREATE TABLE task ("
  "id INT GENERATED ALWAYS AS IDENTITY,"
  "task VARCHAR(32),"
  "done BOOLEAN DEFAULT false"
  ")"])
[0] ;; success! we created the task table 
user&gt; (sql/insert! db :task {:task "Test database"})
((:1 1M)) ;; the sequence of inserted keys:
;; there is just one key, labeled :1, with the value 1
;; the M indicates a BigDecimal value
user&gt; (sql/insert! db :task {:task "Read some data"})
((:1 2M)) ;; generated key is 2 this time
user&gt; (sql/query db ["SELECT * FROM task WHERE NOT done"])
({:done false, :task "Test database", :id 1} {:done false, :task "Read some data", :id 2})
;; our two records came back, let's update one
user&gt; (sql/update! db :task {:done true} ["id = ?" 1])
(1) ;; one row was updated
user&gt; (sql/query db ["SELECT * FROM task WHERE NOT done"])
({:done false, :task "Read some data", :id 2})
;; yup, that's our only task not done now
user&gt; (sql/update! db :task {:done true} ["id = ?" 1])
(1) ;; one row was updated
;; let's delete our table to clean up
user&gt; (sql/execute! db [ "DROP TABLE task"])
[0] ;; success! we dropped the table
</code></pre>

<p>Some notes on the syntax:</p>

<ul>
<li>Functions that modify the database end in <code>!</code> to indicate they have side effects</li>
<li>SQL and any parameters are specified together in a vector:

<ul>
<li><code>["a SQL string" param1 param2 param3]</code></li>
<li>Use <code>?</code> in the SQL string to indicate a parameter</li>
<li>A <code>PreparedStatement</code> is used for all operations</li>
</ul>
</li>
<li><code>execute!</code> can be used for arbitrary SQL or DDL</li>
<li><code>query</code> is intended for <code>SELECT</code> only and returns a result set</li>
<li><code>insert!</code> inserts a new row from a hash map (struct)</li>
<li><code>update!</code> sets the column values shown in the hash map for all rows that match the <code>WHERE</code> clause provided in the vector, so it is shorthand for <code>["UPDATE table SET column values WHERE clause" param1 param2 param3]</code></li>
</ul>


<h2>Adding the initial CFML files</h2>

<h2>Writing a Clojure Service</h2>

<h2>Writing a Clojure Controller</h2>

<h1>A Clojure Primer</h1>

<p>To learn about Clojure in any depth, I&rsquo;d recommend you go through the <strong>More Stuff to Read</strong> section at the end of this
page, but I&rsquo;m going to give you a quick run through of some useful basics that should get you up and running more quickly.</p>

<p>As I claimed earlier, Clojure is a very simple language with only a few pieces of syntax:</p>

<ul>
<li>A semicolon introduces a comment. Typically a single semicolon is used for an end of line comment and a double semicolon is used for
a whole line produces</li>
<li><code>(func arg1 arg2 arg3)</code> represents a function call (with three arguments). You can use commas if you want but they are
just whitespace: <code>(func arg1, arg2, arg3)</code>. Most Clojure developers omit commas in function calls. Almost everything in Clojure is a function call.
A few things that look like function calls are actually &ldquo;<a href="http://clojure.org/special_forms">special forms</a>&rdquo; but you can pretend they&rsquo;re really function calls
until you get a bit more proficient (a function call evaluates all its arguments before the call, a special form may not
evaluate its arguments until it needs them).</li>
<li><code>a</code> is a symbol &mdash; a variable or function name &mdash; that evaluates to whatever it has been bound to. See <code>def</code>, <code>defn</code> and <code>let</code> below.</li>
<li><code>:a</code> is a keyword &mdash; it evaluates to itself &mdash; that is a bit like a string except it is cached (so two <code>:a</code>s in different parts of
your code and the exact same thing and can be compared for identity based on their address, not their value). Keywords are commonly
used as the keys in a hash map (see below).</li>
<li><code>[1 2 3 4]</code> represents a vector (array) with the specified elements. You can use commas if you want, but they are just whitespace:
<code>[1, 2, 3, 4]</code>. Most Clojure developers omit commas in vectors.</li>
<li><code>{:a 1, :b 2, :c 3}</code> represents a hash map (struct) with keys <code>:a</code>, <code>:b</code>, <code>:c</code> and values <code>1</code>, <code>2</code>, <code>3</code> respectively. The commas
are just whitespace but some Clojure developers use them anyway to clearly delineate pairs.</li>
<li><code>#{1 2 3}</code> represents a set of values. If you add <code>4</code> to that set you get <code>#{1 2 3 4}</code> but if you add <code>1</code>, <code>2</code>, or <code>3</code> to it, it remains
unchanged because those values are already in the set. CFML doesn&rsquo;t have a set data type, but you might simulate it with a struct whose
values are <code>true</code> (or some other arbitrary value) and the presence or absence of a key says whether it&rsquo;s in the set or not.</li>
</ul>


<p>That&rsquo;s about it. When you learn about macros (in one of the Clojure books), you&rsquo;ll encounter a few new pieces of syntax but you
don&rsquo;t need that to get going.</p>

<h2>Some Basic Clojure Functions</h2>

<p>Functions all the way down. Some functions / special forms are very important so I&rsquo;m going to go through some of those here.</p>

<h3><code>def</code>, <code>fn</code>, and <code>defn</code></h3>

<p>The <code>def</code> special form creates a global (top-level) binding of a name to a value within the current namespace:</p>

<pre><code>(def a 42)
;; binds a to the value 42 -- technically a is a Var
a
;; produces 42
</code></pre>

<p>The <code>fn</code> special form creates an anonymous function:</p>

<pre><code>(fn [a b c] (* a b c))
;; creates a function with three arguments a, b, and c
;; that multiplies those three values together
</code></pre>

<p>Anonymous functions are often used as arguments to other functions:</p>

<pre><code>(map (fn [x] (* x 2)) [1 2 3 4 5])
;; produces (2 4 6 8 10)
</code></pre>

<p>Strictly speaking, a function can contain more than one expression: they are all evaluated in order, but only the value of the last
expression is returned. The others are throw away. So why have multiple expressions? You might have some operations that cause side
effects, such as logging to file or writing to a database, and you want to evaluate those for their effects but not necessarily
their result.</p>

<p>You can bind a name to an anonymous function, to create a named function:</p>

<pre><code>(def twice (fn [x] (* x 2)))
</code></pre>

<p>This is so common that <code>defn</code> exists as a shorthand for it:</p>

<pre><code>(defn twice [x] (* x 2))
</code></pre>

<p>Documentation is built into Clojure and you can (and should) provide a &ldquo;docstring&rdquo; for all your functions that say what they do
and possibly provide example usage:</p>

<pre><code>(defn twice "Doubles its argument." [x] (* x 2))
</code></pre>

<p>You&rsquo;ll often see this written on multiple lines like this:</p>

<pre><code>(defn sum-of-squares
  "Given two values, return the sum of their squares."
  [a b]
  (+ (* a a) (* b b)))
</code></pre>

<p>It&rsquo;s common for functions to have short argument names because each function should be very short and simple, and the function names should
be descriptive.</p>

<p>The docstring &mdash; and the source code &mdash; of functions is available in the REPL (and in any Clojure editor that supports live evaluation) through
the <code>doc</code> &mdash; and <code>source</code> &mdash; functions (in the <code>clojure.repl</code> namespace). This makes it very easy to experiment with new libraries since all
of the documentation and source code is right there at your fingertips!</p>

<h3><code>if</code>, <code>when</code>, and <code>do</code></h3>

<p>In CFML we have an <code>if</code> statement. If the condition is true, the first group of statements is executed, else the second group of statements
is executed. In functional languages like Clojure, <code>if</code> is an expression (a special form) and it takes a condition and two expressions.
If the condition is true, the first expression is evaluated, else the second expression is evaluated. It&rsquo;s more like the tertiary operator
<code>? :</code> in CFML.</p>

<p>Also, it&rsquo;s important to note that Clojure has strong views on what is true and false. You&rsquo;ll hear of &ldquo;truthy&rdquo; and &ldquo;falsey&rdquo; in the Clojure
world because Clojure treats everything as true except for <code>false</code> and <code>nil</code>. In particular, that means that <code>0</code> is true, unlike in CFML.
The reason for this is an idiom called &ldquo;nil punning&rdquo;: it&rsquo;s common for Clojure functions to return <code>nil</code> for &ldquo;no such value&rdquo; instead of
throwing an exception, and allowing <code>nil</code> to mean false makes it easy to test for such things:</p>

<pre><code>(if (:name rc) (str "Hello " (:name rc) "!") "Who?")
</code></pre>

<p>In CFML, if you did <code>rc.name</code> and it wasn&rsquo;t present, you&rsquo;d get an exception. In Clojure, <code>(:name rc)</code> simple returns <code>nil</code> if there&rsquo;s no
such key and you just test for that. You can prevent repetition of <code>(:name rc)</code> with <code>if-let</code> &mdash; see below.</p>

<p>If you don&rsquo;t have an &ldquo;else&rdquo; expression (and want to return <code>nil</code> instead), use <code>when</code> instead of <code>if</code>:</p>

<pre><code>(when (:name rc) (str "Hello " (:name rc) "!"))
</code></pre>

<p>If the condition is &ldquo;falsey&rdquo;, you get <code>nil</code> back. Be aware that <code>when</code> allows multiple expressions, just like <code>fn</code> above and <code>let</code> below, and it evaluates
all of them but only returns the value of the last expression.</p>

<p>If you want to evaluate multiple expressions in an <code>if</code>, you need <code>do</code>:</p>

<pre><code>(if some-condition
  (do
    (log-something)
    (update-the-database)
    "Result!")
  "Failure!")
</code></pre>

<p><code>do</code> can be used where any single expression is accepted and behaves like the body of <code>fn</code>.</p>

<p>It might not surprise you to learn that <code>when</code> is really defined in terms of <code>if</code> and <code>do</code> something like this:</p>

<pre><code>(when condition expr1 expr2 expr3)
;; is treated like
(if condition (do expr1 expr2 expr3) nil)
</code></pre>

<h3><code>let</code> and its cousins</h3>

<p>Global bindings are fine for functions that you want exposed to the world, but you often want local bindings inside a function. That&rsquo;s what the
<code>let</code> special form is for:</p>

<pre><code>(defn sum-of-squares
  "Given two values, return the sum of their squares."
  [a b]
  (let [a-squared (* a a)
        b-squared (* b b)]
    (+ a-squared b-squared)))
</code></pre>

<p><code>let</code> is following by a vector of bindings &mdash; pairs of symbol and expression &mdash; and then one or more expressions. It creates a local binding
for each pair by evaluating the expression and binding it to the name (symbol), and then it evaluates the expressions in its body and returns
the last expression&rsquo;s value (in the same way function bodies are evaluated).</p>

<p>There are several variants of <code>let</code> that are useful. The most common is probably <code>if-let</code>:</p>

<pre><code>(if-let [name (:name rc)]
  (str "Hello " name "!")
  "Who?")
</code></pre>

<p>Unlike <code>let</code>, <code>if-let</code> only allows one binding pair followed by two expressions. If the binding is &ldquo;truthy&rdquo;, the first expression will be evaluated,
else the second expression will be evaluated. Note that the bound symbol is only available in the <em>first</em> expression!</p>

<h3><code>loop</code> and <code>recur</code></h3>

<p>Since I often tell people that functional programming means no mutable variables and therefore no loops, it might surprise you to learn that
Clojure has a <code>loop</code> construct. It isn&rsquo;t quite what it seems!</p>

<p>First, let&rsquo;s look at a recursive function:</p>

<pre><code>(defn fact [n] (if (zero? n) 1 (* n (fact (dec n)))))
;; (fact 1) =&gt; 1
;; (fact 3) =&gt; 6
;; (fact 5) =&gt; 120
</code></pre>

<p>Because it is recursive, it creates a new stack frame for every call to itself. You can still call it with some big numbers but eventually you will get
a stack overflow:</p>

<pre><code>(fact 1000N) =&gt; 402387260077093773543702433923003985719374...
(fact 10000N) =&gt; StackOverflowError   java.math.BigInteger.valueOf (BigInteger.java:1098)
</code></pre>

<p>There&rsquo;s a technique called tail recursion that allows some languages to evaluate recursive functions without needing stack frames. You
have to rewrite the function to ensure the recursive call is in the tail position (the <code>fact</code> call above is nested inside multiplcation).
Often, you need to create a helper function:</p>

<pre><code>(defn fact-helper [n prod] (if (zero? n) prod (fact-helper (dec n) (* n prod))))
(defn fact [n] (fact-helper n 1))
</code></pre>

<p>This produces the same results as <code>fact</code> above, but now the recursive call to <code>fact-helper</code> is in the tail position. Clojure doesn&rsquo;t optimize this
directly but provides <code>recur</code> for you to tell the compiler you want it optimized &mdash; and to verify you really are using tail recursion:</p>

<pre><code>(defn fact [n] (if (zero? n) 1 (* n (recur (dec n)))))
;; CompilerException: Can only recur from tail position
</code></pre>

<p>But:</p>

<pre><code>(defn fact-helper [n prod] (if (zero? n) prod (recur (dec n) (* n prod))))
(defn fact [n] (fact-helper n 1))
(fact 10000N) =&gt; 28462596809170545189064132121198688901480514...
</code></pre>

<p>You can see that <code>recur</code> replaces the recursive call, but what it&rsquo;s really doing behind the scenes is rebinding the function arguments
and &ldquo;jumping&rdquo; back to the beginning of the function, to avoid a function call altogether. Since this is really a loop-with-rebinding,
Clojure provides a <code>loop</code> construct that lets you do this directly:</p>

<pre><code>(defn fact [n] (loop [n n, prod 1] (if (zero? n) prod (recur (dec n) (* n prod)))))
</code></pre>

<p>This single function is identical in behavior to the <code>fact</code> / <code>fact-helper</code> pair shown immediately above. You can see how the <code>loop</code>
binding behaves just like the initial call to <code>fact-helper</code>, binding <code>fact</code>s argument <code>n</code> to the local symbol <code>n</code> and <code>1</code> to the local
symbol <code>prod</code>.</p>

<h3>Useful core Functions</h3>

<p>Since Clojure is all about data structures, there is a rich selection of functions that operate on them. Some of the valuable ones to know are:</p>

<ul>
<li><code>(first [1 2 3 4])</code> returns the first element of a sequence: <code>1</code></li>
<li><code>(rest [1 2 3 4])</code> returns the rest of a sequence: <code>(2 3 4)</code></li>
</ul>


<p>The <code>rest</code> of a single element sequence is an empty sequence &mdash; <code>()</code> &mdash; and the <code>rest</code> of an empty sequence is <em>also</em> an empty sequence!</p>

<ul>
<li><code>(seq some-collection)</code> returns a sequence of <code>some-collection</code>s elements if it is non-empty, else returns <code>nil</code></li>
</ul>


<p>It is common to test for empty sequences with <code>if (seq some-collection)</code>.</p>

<ul>
<li><code>(cons 1 [2 3 4])</code> returns a new sequence with that element added: <code>(1 2 3 4)</code></li>
<li><code>(assoc {:a 1} :b 2)</code> returns a new hash map with the key associated to the value: <code>{:a 1, :b 2}</code></li>
<li><code>(dissoc {:a 1, :b 2} :a)</code> returns a new hash map with the key removed (dissociated): <code>{:b 2}</code></li>
<li><code>(map inc [1 2 3 4])</code> returns a new sequence with the function applied to each element: <code>(2 3 4 5]</code></li>
<li><code>(filter even? [1 2 3 4])</code> returns a new sequence containing just the elements for which the predicate is &ldquo;truthy&rdquo;: <code>(2 4)</code></li>
<li><code>(reduce + 0 [1 2 3 4])</code> returns the value computed by repeatedly applying the function to the initial value and each element of the sequence: <code>10</code></li>
</ul>


<p>If the initial value is omitted, the first element of the sequence is used so:</p>

<pre><code>(reduce func some-collection)
;; is the same as
(reduce func (first some-collection) (rest some-collection))
</code></pre>

<h3>The <code>project.clj</code> File</h3>

<p>The piece of <code>project.clj</code> you&rsquo;ll touch most often is the <code>:dependencies</code> entry. This is a list of all the libraries your
program needs and the versions of each you want to use:</p>

<pre><code>:dependencies [[org.clojure/clojure "1.6.0"]
               [clj-time "0.9.0"]]
</code></pre>

<p>Libraries come from two locations by default: <a href="http://search.maven.org">Maven Central</a> and <a href="https://clojars.org">Clojars</a>.</p>

<p>Most Clojure libraries tell you what to put in <code>project.clj</code> to pull them in so you mostly won&rsquo;t need to care which location
they actually come from but it&rsquo;s instructive to at least know how to read this stuff and how to search for libraries yourself.</p>

<p>Each entry is called a &ldquo;coordinate&rdquo; and contains a &ldquo;group ID&rdquo; and an &ldquo;artifact ID&rdquo;. A single name just means that the group ID
and artifact ID are the same thing (so <code>clj-time</code> is shorthand for <code>clj-time/clj-time</code>).</p>

<p>To search Maven Central for <code>org.clojure/clojure</code> you would use the query <code>g:"org.clojure" AND a:"clojure"</code> which asks for
group ID <code>org.clojure</code> and artifact ID <code>clojure</code>. Right now there are 74 versions of that library on Maven Central and the
latest is <code>1.7.0-RC1</code> but if you click the <code>All (74)</code> link, you&rsquo;ll see the most recent non-prerelease version is <code>1.6.0</code>
which is what <strong>Leiningen</strong> puts in <code>project.clj</code> by default.</p>

<p>On the other hand, <code>clj-time</code> comes from Clojars because it is a community project. If you search for <code>clj-time</code> you&rsquo;ll
get a lot of results but most of them are not canonical versions. The most recent canonical version is <a href="https://clojars.org/clj-time">https://clojars.org/clj-time</a> but
there are other, earlier canonical versions, such as <a href="https://clojars.org/backtype/clj-time">https://clojars.org/backtype/clj-time</a> so you need to be a bit careful. If in doubt,
get on IRC, Slack, or the mailing list and ask!</p>

<p>For an overview of all the possible settings in <code>project.clj</code>, take a look at the <a href="https://github.com/technomancy/leiningen/blob/master/sample.project.clj">Sample project.clj File on GitHub</a>.</p>

<h2>About Functional Programming</h2>

<p>Functional programming isn&rsquo;t new. It&rsquo;s origins lie in Lisp which was created in the 1950&rsquo;s and is the second-oldest computer language
(second only to FORTRAN). Throughout the 70&rsquo;s and 80&rsquo;s a lot of functional languages were created, mostly in academia, to study the
benefits of the functional style, as well look at levels of expressiveness in programming languages. Classic functional languages
include Standard ML, Miranda, and Haskell. Haskell was a result of the proliferation of similar functional languages being created
by each university in England (and elsewhere). It was decided that a single, committee-designed functional language should exist
that included the best ideas of all of the diverse variants out there. Haskell is probably the most widely used language today from
that era. It has an extremely powerful type system and a very strong view of purity &mdash; lack of side effects &mdash; but it has been
used extensively over the last 25 years in industry as well as academia.</p>

<p>The recent resurgence of functional programming has shown itself in languages like F# from Microsoft, Scala, and Clojure, even Rust, as well
as some compile-to-JS languages like Elm and PureScript. The reason behind this resurgence is that immutable data structures and
pure functions offer the ability to write concurrent code a lot more easily and lot more safely than the mainstream OOP approach.
And we need concurrency in order to take advantage of multi-core machines, now that we&rsquo;re no longer seeing continued speed increases
in individual cores like we have for the last several decades.</p>

<p>While it may seem obvious that functional programming leans heavily on functions as building blocks, the real core values of
functional programming are avoiding mutable data and avoiding side effects in functions. The more that you can push side effects
to the edges of your program, the more of your code becomes pure functions that can be easily reasoned about, easily tested, and
often easily reused. Functional programming focuses on small, pure functions that can be composed to create larger pieces of
functionality. If you have a function <code>inc</code> that adds one to its argument and a function <code>twice</code> that doubles its argument, then
<code>(comp twice inc)</code> is a function that adds one to its argument and then doubles it: functions are like Legos that you can easily
assemble to build products.</p>

<h3>Immutable or Persistent Data Structures</h3>

<p>In the context of functional programming, you&rsquo;ll hear a lot of talk of immutable data structures and persistent data structures.
In OOP languages, you typically perform operations on a data structure to modify it in place. That means you can&rsquo;t safely share
it with other pieces of code, especially across multiple threads. By constrast, in a functional language, when you perform an
operation on a data structure, you get a new data structure back, that shares as much structure as possible with the original
data structure &mdash; and that leaves the original data structure unchanged.</p>

<p>While they are designed for efficiency, it is usually at scale, rather than for small examples. In Clojure, many data structures
are &ldquo;chunked&rdquo; internally into groups of 32 elements. A vector of 100 elements is going to be four chunks and is optimized for
adding elements to the end of the vector. A list is optimized for adding elements at the start of it. A hash map is also chunked
and optimized for adding elements in random locations. They are also optimized for different patterns of access: a list is optimized
for purely sequential access, a vector for indexed (random) access, and a hash map for keyed (random) access.</p>

<p>Clojure and Scala share a lot of heavily optimized implementation details in their persistent data structures.</p>

<p>Despite all this efficiency, you still need to think about how to use data structures, and there are going to be some algorithms
where bashing a data structure in place is just going to be faster. It won&rsquo;t be as safe, just faster. Clojure is fine with the
idea of localized mutation and has versions of vectors and hash maps that are optimized for that purpose (known as transients).</p>

<p>The most important aspect of these data structures in Clojure is the set of abstractions over them, including &ldquo;sequence&rdquo;
and &ldquo;associative&rdquo;. These are uniform ways to think
about data structures as just sequences of data (accessed in order, or randomly by keys),
no matter what their actual implementation is, so that you can apply all of
Clojure&rsquo;s core functions to arbitrary data structures in standardized ways. The lack of unique types for each data structure
you use means that you don&rsquo;t need unique functions to operate on them all. A function that operates on a sequence can accept
any data structure that supports the sequence abstraction. A function that operates on an associative collection can accept
any data structure that supports the associative abstraction.</p>

<p>For example, a result set from a database query is simply a sequence of associative collections. It can be mapped, filtered,
reduced using standard functions and its rows transformed using any of the standard associative functions. This allows
abstraction over different data stores as well since, from Clojure&rsquo;s point of view, MySQL and MongoDB look very similar.</p>

<h3>Functions as Building Blocks</h3>

<p>I&rsquo;ve already emphasized that functional programming favors small, simple, pure functions but you can do that sort of
functional decomposition in most languages. Many modern languages allow you to write anonymous functions and pass them
around as arguments, as well as return them from functions. Even with those features available, it takes a while to
shift from an imperative style with some functions being passed around to a functional style where functions are your
primary abstraction.</p>

<p>You&rsquo;ll hear the term &ldquo;higher order functions&rdquo; a lot but all this means is a function that accepts a function as one (or
more) of its arguments or a function that returns a function as a result. You&rsquo;ll see the former in CFML with the new
<code>map</code>, <code>filter</code>, and <code>reduce</code> member functions &mdash; or perhaps you&rsquo;ve seen it in JavaScript.</p>

<p>Consider these two functions (in CFML):</p>

<pre><code>function saveStuff( data ) {
    if ( validStuff( data ) ) {
        dbSave( "stuffTable", data );
    } else {
        writeLog( "Invalid stuff, not saved" );
    }
}

function saveThing( data ) {
    if ( thingIsValid( "all", data ) ) {
        dbSave( "thingTable", data );
    } else {
        writeLog( "Invalid thing, not saved" );
    }
}
</code></pre>

<p>Now, consider this function:</p>

<pre><code>function saveValidData( validator, type, data ) {
    if ( validator( data ) ) {
        dbSave( type &amp; "Table", data );
    } else {
        writeLog( "Invalid #type#, not saved" );
    }
}
</code></pre>

<p>This is probably not a transform you would do in CFML but it&rsquo;s a natural one in a functional language, because
you would see the commonality and want to remove the duplication:</p>

<pre><code>var saveStuff = function( data ) { return saveValidData( validStuff, "stuff", data ); };
var saveThing = function( data ) {
    return saveValidData(
        function( data ) { return thingIsValid( "all", data ); },
        "thing",
        data
    );
}
</code></pre>

<p>Now imagine you had a higher order function called
<code>partial</code> that accepted a function and one or more of its arguments and returned a new function that accepted
the rest of its arguments and then called it, it would be very natural to make this transform and then write:</p>

<pre><code>var saveStuff = partial( saveValidData, validStuff, "stuff" );
var saveThing = partial( saveValidData, partial( thingIsValid, "all" ), "thing" );
</code></pre>

<p>This is much cleaner, especially if you had quite a few of these &ldquo;save data if valid&rdquo; variants.</p>

<p>Another way to write this without <code>partial</code> would be:</p>

<pre><code>function thingIsAllValid( data ) { return thingIsValid( "all", data ); }
function saveValidData( validator, type ) {
    // accept validator and type, return a function that accepts data
    return function( data ) {
        if ( validator( data ) ) {
            dbSave( type &amp; "Table", data );
        } else {
            writeLog( "Invalid #type#, not saved" );
        }
    }
}

var saveStuff = saveValidData( validStuff, "stuff" ); // returns a function
var saveThing = saveValidData( thingIsAllValid, "thing" );
</code></pre>

<p>You could also write &ldquo;thing&rdquo; validation like this:</p>

<pre><code>function thingValidator( scope ) {
    return function( data ) {
        return thingIsValid( scope, data );
    }
}

var saveThing = saveValidData( thingValidator( "all" ), "thing" );
</code></pre>

<p>By making our functions more flexible in how they accept arguments, we make it easier to reuse them. This is functional thinking!</p>

<p>In Clojure we can define a function with multiple argument lists so this becomes even easier:</p>

<pre><code>(defn thing-is-valid
  ([scope] (fn [data] (thing-is-valid scope data)))
  ([scope data] ... return true or false ...))

(defn save-valid-data
  ([validator type] (fn [data] (save-valid-data validator type data)))
  ([validator type data]
   (if (validator data)
     (db-save (str type "Table") data)
     (write-log (str "Invalid " type ", not saved")))))

(def save-stuff (save-valid-data valid-stuff "stuff"))
(def save-thing (save-valid-data (thing-is-valid "all") "thing")
</code></pre>

<p>No need for <code>partial</code> (although Clojure has that built-in), no need for helper functions.</p>

<h2>All You Know About OO Programming is Wrong</h2>

<p>I learned old-fashioned imperative procedural programming first. I learned BASIC, assembly language, Pascal and later
COBOL and FORTRAN. Although OOP has its roots back in the 50&rsquo;s and 60&rsquo;s (ironically, with Lisp, just like FP has its
roots in Lisp), it didn&rsquo;t really go mainstream until the mid-to-late 80&rsquo;s with the arrival of Eiffel and C++. I
learned a lot of FP during the 80&rsquo;s but since it wasn&rsquo;t going mainstream and OOP was, I switched horses to stay
employable. By the time Java appeared, OOP had become the default &ldquo;standard&rdquo; way to build software, even though
C++ and Java were not at all what Alan Kay had in mind when he coined the phrase &ldquo;object-oriented&rdquo;.</p>

<p>What most developers know as modern OOP focuses on polymorhism, inheritance, encapsulation and objects that have both
state and behavior bundled together. You construct an object with its initial state. You run a bunch of methods on it,
interacting with other objects, to modify its state, and then you query the object to get that state back out.</p>

<p>A common idiom in the OOP world for collections is an iterator. In CFML this shows up in query objects. As you loop
over the iterator, it changes its state to refer to successive elements of the underlying collection. A CFML query
refers to successive rows of the result set as you loop over it and the <code>currentrow</code> element is updated at each
iteration. Instead of a result set looking like a sequence of rows, we&rsquo;re used to looking at a snapshot of the &ldquo;current
row&rdquo; &mdash; and that&rsquo;s what iterators do to us for collections as well.</p>

<p>In addition, instead of processing collections holistically to produce either new collections or specific results,
we&rsquo;re using to iterating through the elements and either modifying them in place or performing side effecting operations
along the way.</p>

<p>What makes this problematic is that you can&rsquo;t then easily run this code concurrently to take advantage of multiple cores:
code that mutates collections in places or generates side effects is rarely thread safe.</p>

<p>In other words, mutable state is bad.</p>

<p>What about OOP&rsquo;s other basic tenets?</p>

<p>Why do you encapsulate data? The primary reason is so that you can control mutation of that data. If your data is
immutable, encapsulation is no longer needed for that. The other argument for encapsulation is so that you can
change the representation of the state without affecting your clients. In a functional world, if you change your
representation, you can always provide a function that transforms it to the original structure and then simply
compose that transformation with any client function that needs to access it. That composed client + transform
can be refactored away over time as the client transitions to the new API. In other words, your data is your API
and there&rsquo;s no need to encapsulate it (at least, not for the traditional OOP reasons).</p>

<p>Inheritance? Inheritance exists in OOP because the notion of data types is inherently tied to classes and objects.
Inheritance represents a strong coupling between an implementation and an interface or between one implementation
and another related implementation. It exists because there&rsquo;s no way to separate out the notion of data types and
their relationships from the class implementation relationships. Needless to say, in a functional world, you can
choose to have relationships between data types as you need them, without being forced to create relationships
between data representations. In Clojure, in particular, you can create hierarchies of types independent of
any data and use those to guide function call dispatching.</p>

<p>Which brings us nicely to polymorphism! Polymorphism is great. It&rsquo;s very useful. Unfortunately, in OOP it is
tied to inheritance which, as we&rsquo;ve just seen, is all about coupling when you&rsquo;re dealing with classes. If you
only ever use interfaces and pure implementations, you can free yourself from some of the problems of coupling
forced on you by OOP, but you still get stuck if you have a class (implementation) that isn&rsquo;t declared to
implement an interface that you need to use, even though it has the right methods. Nor can you easily take
an arbitrary existing class and make it implement your interface (you can extend the class and implement your
interface, only if the class is not final in Java, for example). In addition to all that, polymorphism in OOP
is only effective on the first argument &mdash; the object type itself &mdash; which means that when faced with more
complex problems, you have to resort to design patterns like Visitor and implement double dispatch. But then
you are forced to modify the &ldquo;visited&rdquo; class every time you want to visit it with a new class. What you really
need there is polymorphism based on multiple arguments. Fortunately, you can have that in functional programming.</p>

<p>So what have we learned?</p>

<p>Polymorphism is very limited in OOP but can be very powerful in FP once we remove the restriction of single
dispatch and the coupling to a static inheritance hierarchy: this gives you ad hoc or a la carte polymorphism.</p>

<p>Inheritance as seen in OOP is essentially an implementation detail. You can have ad hoc inheritance in FP,
which provides expressiveness where you want it and avoids boilerplate and coupling where you don&rsquo;t.</p>

<p>Encapsulation is required in OOP when you have mutatable state and is also needed in order to allow changes in
implementation. In other words, encapsulation is also essentially an implementation detail. FP solves this
by making data immutable and making functions easily composable.</p>

<p>Mutable state is just bad. It prevents refactoring to leverage concurrency, it leads to hard to find bugs
in complex programs, and it also erases any notion of time in your program (because you have only the
current version of the state, rather than the series of values that were transformed to get to that point).
FP solves that by removing mutability.</p>

<p>If FP is so great, why aren&rsquo;t we all using it already?</p>

<p>Good question. The OOP industry is vast. Design Patterns, training and consulting, higher education based on
teaching OOP (ironically after supplanting a lot of courses that taught FP!), testing, tooling, IDEs. The
momentum behind OOP is huge and the inertia of industry to keep doing things the way they know is almost
overwhelming. Yet we see functional features in nearly every new language being designed, we see functional
features being added to nearly every existing language over time, we see the functional style of programming
being advocated even in traditional languages &mdash; with less reliance on mutable state. Most of that pressure
is coming from the need to do more concurrency and to avoid the bugs that arise from side-effecting code.
In other words, a lot of people already know that FP is a better way to solve a lot of problems.</p>

<p>Remember that modern OOP &mdash; as enshrined in Java and C# particularly &mdash; is not what the originators of OOP had
in mind. They imagined objects as proxies for real world elements such as displays and control devices, that
objects would be coarse-grained and communicate by sending messages between themselves.</p>

<h2>More Stuff to Read</h2>

<p>Once you&rsquo;ve got a taste for Clojure, there are lots of online resources and a host of great books you can read.
Here&rsquo;s a small sample, roughly in order of approachability:</p>

<ul>
<li>The online tutorial for learning Clojure, no installation required: <a href="http://www.tryclj.com">http://www.tryclj.com</a></li>
<li>The &ldquo;4Clojure&rdquo; puzzles online: <a href="https://www.4clojure.com">https://www.4clojure.com</a>

<ul>
<li>These quickly get hard enough that you&rsquo;ll want a REPL open locally to play with!</li>
</ul>
</li>
<li>The Clojure Koans: <a href="http://clojurekoans.com">http://clojurekoans.com</a>

<ul>
<li>You need at least Java, Leiningen, and Git installed for these.</li>
</ul>
</li>
<li>Some great books to read:

<ul>
<li>Clojure Programming <a href="http://www.clojurebook.com">http://www.clojurebook.com</a> followed by</li>
<li>The Joy Of Clojure <a href="http://www.joyofclojure.com">http://www.joyofclojure.com</a> :)</li>
</ul>
</li>
</ul>


<h1>Digging Into Reloading</h1>

  
    <footer>
      <p class="meta">
        
        








  


<time datetime="2015-07-12T21:40:00-07:00" pubdate data-updated="true">Jul 12<span>th</span>, 2015</time>
        
      </p>
      
    </footer>
  
</article>

</div>

<aside class="sidebar">
  
    <section>
    <h1>About FW/1</h1>
    <p>FW/1 - Framework One - is a family of small, lightweight, convention-over-configuration frameworks, primarily for CFML. FW/1 itself provides MVC, DI/1 provides dependency injection (a.k.a. inversion of control), and AOP/1 provides aspect-oriented programming features on top of DI/1.</p>
    <p>In addition, the family includes cfmljure, an easy way to integrate Clojure code into your CFML application, and a port of FW/1 to Clojure as well as a Leiningen template for creating FW/1 projects in Clojure.</p>
</section>
<section>
    <h1>3.1 Documentation (master)</h1>
    <a href="/documentation">Getting Started Guide</a><br />
    <a href="/documentation/developing-applications.html">Developing Applications Guide</a><br />
    <a href="/documentation/using-aop-one.html">Using AOP/1</a><br />
    <a href="/documentation/using-di-one.html">Using DI/1</a><br />
    <a href="/documentation/using-subsystems.html">Using Subsystems</a><br />
    <a href="/documentation/reference-manual.html">Reference Manual</a><br />
    <a href="/documentation/roadmap.html">Roadmap</a><br />
</section>
<section>
    <h1>3.0 Documentation (stable)</h1>
    <a href="/documentation/3.0">Getting Started Guide</a><br />
    <a href="/documentation/3.0/developing-applications.html">Developing Applications Guide</a><br />
    <a href="/documentation/3.0/using-di-one.html">Using DI/1</a><br />
    <a href="/documentation/3.0/using-subsystems.html">Using Subsystems</a><br />
    <a href="/documentation/3.0/reference-manual.html">Reference Manual</a><br />
    <a href="/documentation/3.0/roadmap.html">Roadmap</a><br />
</section>
<section>
    <h1>3.5 Documentation (upcoming - develop)</h1>
    <a href="/documentation/3.5">Getting Started Guide</a><br />
    <a href="/documentation/3.5/developing-applications.html">Developing Applications Guide</a><br />
    <a href="/documentation/3.5/using-aop-one.html">Using AOP/1</a><br />
    <a href="/documentation/3.5/using-di-one.html">Using DI/1</a><br />
    <a href="/documentation/3.5/using-subsystems.html">Using Subsystems</a><br />
    <a href="/documentation/3.5/reference-manual.html">Reference Manual</a><br />
    <a href="/documentation/3.5/roadmap.html">Roadmap</a><br />
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/07/12/fw1-3-1-released/">FW/1 3.1 Released!</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/07/fw1-3-1-rc-2/">FW/1 3.1 Release Candidate 2 Available!</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/28/fw1-3-1-rc-1/">FW/1 3.1 Release Candidate 1 Available!</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/20/fw1-3-1-beta-2/">FW/1 3.1 Beta 2 Available!</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/14/fw1-3-1-beta-1/">FW/1 3.1 Beta 1 Available!</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/09/fw1-2-5-1-2-2-2-important/">FW/1 2.5.2 & 2.2.3 - Important Updates!</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/09/fw1-3-0-1-important/">FW/1 3.0.2 - Important Update!</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/21/fw1-3-1-begins/">FW/1 3.1 Begins...</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/24/fw1-3-0-released/">FW/1 3.0 Released!</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/06/fw1-3-0-rc-2-available/">FW/1 3.0 RC 2 Available</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/framework-one">@framework-one</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'framework-one',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>
<section>
  <a href="https://github.com/seancorfield">@seancorfield</a> on GitHub
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Sean Corfield -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
